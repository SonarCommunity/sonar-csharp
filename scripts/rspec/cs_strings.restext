S100_Category=Sonar Code Smell
S100_Description=Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not method and property names are camel cased. To reduce noise, two consecutive upper case characters are allowed unless they form the whole name. So, MyXMethod is compliant, but XM on its own is not.
S100_IsActivatedByDefault=False
S100_Remediation=Constant/Issue
S100_RemediationCost=5min
S100_Severity=Minor
S100_Tags=convention
S100_Title=Methods and properties should be named in camel case
S100_Type=CODE_SMELL
S1006_Category=Sonar Code Smell
S1006_Description=Default arguments are determined by the static type of the object. If a default argument is different for a parameter in an overriding method, the value used in the call will be different when calls are made via the base or derived object, which may be contrary to developer expectations. 
S1006_IsActivatedByDefault=True
S1006_Remediation=Constant/Issue
S1006_RemediationCost=2min
S1006_Severity=Critical
S1006_Tags=misra,cert,pitfall
S1006_Title=Method overrides should not change parameter defaults
S1006_Type=CODE_SMELL
S101_Category=Sonar Code Smell
S101_Description=Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not type names are camel cased. To reduce noise, two consecutive upper case characters are allowed unless they form the whole type name. So, MyXClass is compliant, but XC on its own is not.
S101_IsActivatedByDefault=True
S101_Remediation=Constant/Issue
S101_RemediationCost=5min
S101_Severity=Minor
S101_Tags=convention
S101_Title=Types should be named in camel case
S101_Type=CODE_SMELL
S103_Category=Sonar Code Smell
S103_Description=Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.
S103_IsActivatedByDefault=False
S103_Remediation=Constant/Issue
S103_RemediationCost=1min
S103_Severity=Major
S103_Tags=convention
S103_Title=Lines should not be too long
S103_Type=CODE_SMELL
S104_Category=Sonar Code Smell
S104_Description=A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those smaller files will not only be easier to understand but also probably easier to test.
S104_IsActivatedByDefault=False
S104_Remediation=Constant/Issue
S104_RemediationCost=1h
S104_Severity=Major
S104_Tags=brain-overload
S104_Title=Files should not have too many lines of code
S104_Type=CODE_SMELL
S105_Category=Sonar Code Smell
S105_Description=Developers should not need to configure the tab width of their text editors in order to be able to read source code.
S105_IsActivatedByDefault=False
S105_Remediation=Constant/Issue
S105_RemediationCost=2min
S105_Severity=Minor
S105_Tags=convention
S105_Title=Tabulation characters should not be used
S105_Type=CODE_SMELL
S1066_Category=Sonar Code Smell
S1066_Description=Merging collapsible if statements increases the code's readability.
S1066_IsActivatedByDefault=True
S1066_Remediation=Constant/Issue
S1066_RemediationCost=5min
S1066_Severity=Major
S1066_Tags=clumsy
S1066_Title=Collapsible "if" statements should be merged
S1066_Type=CODE_SMELL
S1067_Category=Sonar Code Smell
S1067_Description=The complexity of an expression is defined by the number of &&, || and condition ? ifTrue : ifFalse operators it contains.
S1067_IsActivatedByDefault=False
S1067_Remediation=Constant/Issue
S1067_RemediationCost=3min
S1067_Severity=Critical
S1067_Tags=brain-overload
S1067_Title=Expressions should not be too complex
S1067_Type=CODE_SMELL
S107_Category=Sonar Code Smell
S107_Description=A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many things.
S107_IsActivatedByDefault=True
S107_Remediation=Constant/Issue
S107_RemediationCost=20min
S107_Severity=Major
S107_Tags=brain-overload
S107_Title=Methods should not have too many parameters
S107_Type=CODE_SMELL
S1075_Category=Sonar Code Smell
S1075_Description=Hardcoding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may not exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems usually differ from the development environment, ...etc. For all those reasons, a URI should never be hardcoded. Instead, it should be replaced by customizable parameter.
S1075_IsActivatedByDefault=True
S1075_Remediation=Constant/Issue
S1075_RemediationCost=20min
S1075_Severity=Minor
S1075_Tags=cert
S1075_Title=URIs should not be hardcoded
S1075_Type=CODE_SMELL
S108_Category=Sonar Code Smell
S108_Description=Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.
S108_IsActivatedByDefault=True
S108_Remediation=Constant/Issue
S108_RemediationCost=5min
S108_Severity=Major
S108_Tags=suspicious
S108_Title=Nested blocks of code should not be left empty
S108_Type=CODE_SMELL
S110_Category=Sonar Code Smell
S110_Description=Inheritance is certainly one of the most valuable concepts in object-oriented programming. It's a way to compartmentalize and reuse code by creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object oriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better.
S110_IsActivatedByDefault=True
S110_Remediation=
S110_RemediationCost=
S110_Severity=Major
S110_Tags=design
S110_Title=Inheritance tree of classes should not be too deep
S110_Type=CODE_SMELL
S1104_Category=Sonar Vulnerability
S1104_Description=Public fields in public classes do not respect the encapsulation principle and has three main disadvantages:
S1104_IsActivatedByDefault=True
S1104_Remediation=Constant/Issue
S1104_RemediationCost=10min
S1104_Severity=Minor
S1104_Tags=cwe
S1104_Title=Fields should not have public accessibility
S1104_Type=VULNERABILITY
S1109_Category=Sonar Code Smell
S1109_Description=Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line.
S1109_IsActivatedByDefault=False
S1109_Remediation=Constant/Issue
S1109_RemediationCost=1min
S1109_Severity=Minor
S1109_Tags=convention
S1109_Title=A close curly brace should be located at the beginning of a line
S1109_Type=CODE_SMELL
S1116_Category=Sonar Code Smell
S1116_Description=Empty statements, i.e. ;, are usually introduced by mistake, for example because:
S1116_IsActivatedByDefault=True
S1116_Remediation=Constant/Issue
S1116_RemediationCost=2min
S1116_Severity=Minor
S1116_Tags=misra,cert,unused
S1116_Title=Empty statements should be removed
S1116_Type=CODE_SMELL
S1117_Category=Sonar Code Smell
S1117_Description=Shadowing fields with a local variable is a bad practice that reduces code readability: it makes it confusing to know whether the field or the variable is being used.
S1117_IsActivatedByDefault=True
S1117_Remediation=Constant/Issue
S1117_RemediationCost=5min
S1117_Severity=Major
S1117_Tags=cert,pitfall
S1117_Title=Local variables should not shadow class fields
S1117_Type=CODE_SMELL
S1118_Category=Sonar Code Smell
S1118_Description=Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.
S1118_IsActivatedByDefault=True
S1118_Remediation=Constant/Issue
S1118_RemediationCost=10min
S1118_Severity=Major
S1118_Tags=design
S1118_Title=Utility classes should not have public constructors
S1118_Type=CODE_SMELL
S112_Category=Sonar Code Smell
S112_Description=Throwing such general exceptions as Exception, SystemException, ApplicationException, IndexOutOfRangeException, NullReferenceException, OutOfMemoryException and ExecutionEngineException prevents calling methods from handling true, system-generated exceptions differently than application-generated errors. 
S112_IsActivatedByDefault=True
S112_Remediation=Constant/Issue
S112_RemediationCost=20min
S112_Severity=Major
S112_Tags=cwe,error-handling,cert
S112_Title=General exceptions should never be thrown
S112_Type=CODE_SMELL
S1121_Category=Sonar Code Smell
S1121_Description=Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have side-effects.
S1121_IsActivatedByDefault=True
S1121_Remediation=Constant/Issue
S1121_RemediationCost=5min
S1121_Severity=Major
S1121_Tags=cwe,misra,cert,suspicious
S1121_Title=Assignments should not be made from within sub-expressions
S1121_Type=CODE_SMELL
S1123_Category=Sonar Code Smell
S1123_Description=The Obsolete attribute can be applied with or without arguments, but marking something Obsolete without including advice as to why it's obsolete or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time the warning is encountered.
S1123_IsActivatedByDefault=True
S1123_Remediation=Constant/Issue
S1123_RemediationCost=5min
S1123_Severity=Major
S1123_Tags=obsolete,bad-practice
S1123_Title="Obsolete" attributes should include explanations
S1123_Type=CODE_SMELL
S1125_Category=Sonar Code Smell
S1125_Description=Redundant Boolean literals should be removed from expressions to improve readability.
S1125_IsActivatedByDefault=True
S1125_Remediation=Constant/Issue
S1125_RemediationCost=2min
S1125_Severity=Minor
S1125_Tags=clumsy
S1125_Title=Boolean literals should not be redundant
S1125_Type=CODE_SMELL
S1134_Category=Sonar Code Smell
S1134_Description=FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.
S1134_IsActivatedByDefault=True
S1134_Severity=Major
S1134_Tags=cwe
S1134_Title=Track uses of "FIXME" tags
S1134_Type=CODE_SMELL
S1135_Category=Sonar Code Smell
S1135_Description=TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.
S1135_IsActivatedByDefault=True
S1135_Severity=Info
S1135_Tags=cwe
S1135_Title=Track uses of "TODO" tags
S1135_Type=CODE_SMELL
S1144_Category=Sonar Code Smell
S1144_Description=private or internal types or private members that are never executed or referenced are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.
S1144_IsActivatedByDefault=True
S1144_Remediation=Constant/Issue
S1144_RemediationCost=5min
S1144_Severity=Major
S1144_Tags=cert,unused
S1144_Title=Unused private types or members should be removed
S1144_Type=CODE_SMELL
S1145_Category=Sonar Bug
S1145_Description=if statements with conditions that are always false have the effect of making blocks of code non-functional. if statements with conditions that are always true are completely redundant, and make the code less readable.
S1145_IsActivatedByDefault=False
S1145_Remediation=Constant/Issue
S1145_RemediationCost=2min
S1145_Severity=Major
S1145_Tags=cwe,misra
S1145_Title=Useless "if(true) {...}" and "if(false){...}" blocks should be removed
S1145_Type=BUG
S1155_Category=Sonar Code Smell
S1155_Description=Using .Count() to test for emptiness works, but using .Any() makes the intent clearer, and the code more readable. However, there are some cases where special attention should be paid:
S1155_IsActivatedByDefault=True
S1155_Remediation=Constant/Issue
S1155_RemediationCost=2min
S1155_Severity=Minor
S1155_Tags=clumsy
S1155_Title="Any()" should be used to test for emptiness
S1155_Type=CODE_SMELL
S1163_Category=Sonar Code Smell
S1163_Description=Throwing an exception from within a finally block will mask any exception which was previously thrown in the try or catch block, and the masked's exception message and stack trace will be lost.
S1163_IsActivatedByDefault=True
S1163_Remediation=Constant/Issue
S1163_RemediationCost=30min
S1163_Severity=Critical
S1163_Tags=error-handling,cert,suspicious
S1163_Title=Exceptions should not be thrown in finally blocks
S1163_Type=CODE_SMELL
S1168_Category=Sonar Code Smell
S1168_Description=Returning null instead of an actual array or collection forces callers of the method to explicitly test for nullity, making them more complex and less readable.
S1168_IsActivatedByDefault=True
S1168_Remediation=Constant/Issue
S1168_RemediationCost=30min
S1168_Severity=Major
S1168_Tags=cert
S1168_Title=Empty arrays and collections should be returned instead of null
S1168_Type=CODE_SMELL
S1172_Category=Sonar Code Smell
S1172_Description=Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.
S1172_IsActivatedByDefault=True
S1172_Remediation=Constant/Issue
S1172_RemediationCost=5min
S1172_Severity=Major
S1172_Tags=misra,cert,unused
S1172_Title=Unused method parameters should be removed
S1172_Type=CODE_SMELL
S1185_Category=Sonar Code Smell
S1185_Description=Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time this is justified is in sealed overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides of Equals and GetHashCode.
S1185_IsActivatedByDefault=True
S1185_Remediation=Constant/Issue
S1185_RemediationCost=2min
S1185_Severity=Minor
S1185_Tags=redundant,clumsy
S1185_Title=Overriding members should do more than simply call the same member in the base class
S1185_Type=CODE_SMELL
S1186_Category=Sonar Code Smell
S1186_Description=There are several reasons for a method not to have a method body:
S1186_IsActivatedByDefault=True
S1186_Remediation=Constant/Issue
S1186_RemediationCost=5min
S1186_Severity=Critical
S1186_Tags=suspicious
S1186_Title=Methods should not be empty
S1186_Type=CODE_SMELL
S1200_Category=Sonar Code Smell
S1200_Description=According to the Single Responsibility Principle, introduced by Robert C. Martin in his book "Principles of Object Oriented Design", a class should have only one responsibility:
S1200_IsActivatedByDefault=False
S1200_Remediation=Constant/Issue
S1200_RemediationCost=2h
S1200_Severity=Major
S1200_Tags=brain-overload
S1200_Title=Classes should not be coupled to too many other classes (Single Responsibility Principle)
S1200_Type=CODE_SMELL
S1206_Category=Sonar Bug
S1206_Description=There is a contract between Equals(object) and GetHashCode(): If two objects are equal according to the Equals(object) method, then calling GetHashCode() on each of them must yield the same result. If this is not the case, many collections won't handle class instances correctly.
S1206_IsActivatedByDefault=True
S1206_Remediation=Constant/Issue
S1206_RemediationCost=15 min
S1206_Severity=Minor
S1206_Tags=cwe,cert
S1206_Title="Equals(Object)" and "GetHashCode()" should be overridden in pairs
S1206_Type=BUG
S121_Category=Sonar Code Smell
S121_Description=While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.
S121_IsActivatedByDefault=False
S121_Remediation=Constant/Issue
S121_RemediationCost=2min
S121_Severity=Critical
S121_Tags=misra,cert,pitfall
S121_Title=Control structures should use curly braces
S121_Type=CODE_SMELL
S1210_Category=Sonar Code Smell
S1210_Description=When you implement IComparable or IComparable<T> on a class you should also override Equals(object) and overload the comparison operators (==, !=, <, <=, >, >=). That's because the CLR cannot automatically call your CompareTo implementation from Equals(object) or from the base comparison operator implementations. Additionally, it is best practice to override GetHashCode along with Equals.
S1210_IsActivatedByDefault=True
S1210_Remediation=Constant/Issue
S1210_RemediationCost=15min
S1210_Severity=Minor
S1210_Tags=
S1210_Title="Equals" and the comparison operators should be overridden when implementing "IComparable"
S1210_Type=CODE_SMELL
S1215_Category=Sonar Code Smell
S1215_Description=Calling GC.Collect is rarely necessary, and can significantly affect application performance. That's because it triggers a blocking operation that examines every object in memory for cleanup. Further, you don't have control over when this blocking cleanup will actually run.
S1215_IsActivatedByDefault=True
S1215_Remediation=Constant/Issue
S1215_RemediationCost=30min
S1215_Severity=Critical
S1215_Tags=performance,unpredictable,bad-practice
S1215_Title="GC.Collect" should not be called
S1215_Type=CODE_SMELL
S122_Category=Sonar Code Smell
S122_Description=For better readability, do not put more than one statement on a single line.
S122_IsActivatedByDefault=False
S122_Remediation=Constant/Issue
S122_RemediationCost=1min
S122_Severity=Major
S122_Tags=style
S122_Title=Statements should be on separate lines
S122_Type=CODE_SMELL
S1226_Category=Sonar Code Smell
S1226_Description=While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate results.
S1226_IsActivatedByDefault=False
S1226_Remediation=Constant/Issue
S1226_RemediationCost=5min
S1226_Severity=Minor
S1226_Tags=misra,pitfall
S1226_Title=Method parameters and caught exceptions should not be reassigned
S1226_Type=CODE_SMELL
S1227_Category=Sonar Code Smell
S1227_Description=break; is an unstructured control flow statement which makes code harder to read.
S1227_IsActivatedByDefault=False
S1227_Remediation=Constant/Issue
S1227_RemediationCost=10min
S1227_Severity=Minor
S1227_Tags=
S1227_Title=break statements should not be used except for switch cases
S1227_Type=CODE_SMELL
S1244_Category=Sonar Bug
S1244_Description=Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is not associative; push a float or a double through a series of simple mathematical operations and the answer will be different based on the order of those operation because of the rounding that takes place at each step.
S1244_IsActivatedByDefault=False
S1244_Remediation=Constant/Issue
S1244_RemediationCost=5min
S1244_Severity=Major
S1244_Tags=misra
S1244_Title=Floating point numbers should not be tested for equality
S1244_Type=BUG
S125_Category=Sonar Code Smell
S125_Description=Programmers should not comment out code as it bloats programs and reduces readability.
S125_IsActivatedByDefault=True
S125_Remediation=Constant/Issue
S125_RemediationCost=5min
S125_Severity=Major
S125_Tags=misra,unused
S125_Title=Sections of code should not be "commented out"
S125_Type=CODE_SMELL
S126_Category=Sonar Code Smell
S126_Description=This rule applies whenever an if statement is followed by one or more else if statements; the final else if should be followed by an else statement.
S126_IsActivatedByDefault=False
S126_Remediation=Constant/Issue
S126_RemediationCost=5min
S126_Severity=Critical
S126_Tags=misra,cert
S126_Title="if ... else if" constructs should end with "else" clauses
S126_Type=CODE_SMELL
S127_Category=Sonar Code Smell
S127_Description=A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins. 
S127_IsActivatedByDefault=False
S127_Remediation=Constant/Issue
S127_RemediationCost=10min
S127_Severity=Major
S127_Tags=misra,pitfall
S127_Title="for" loop stop conditions should be invariant
S127_Type=CODE_SMELL
S1301_Category=Sonar Code Smell
S1301_Description=switch statements are useful when there are many different cases depending on the value of the same expression.
S1301_IsActivatedByDefault=False
S1301_Remediation=Constant/Issue
S1301_RemediationCost=5min
S1301_Severity=Minor
S1301_Tags=misra,bad-practice
S1301_Title="switch" statements should have at least 3 "case" clauses
S1301_Type=CODE_SMELL
S1309_Category=Sonar Code Smell
S1309_Description=This rule allows you to track the usage of the SuppressMessage attributes and #pragma warning disable mechanism.
S1309_IsActivatedByDefault=False
S1309_Remediation=Constant/Issue
S1309_RemediationCost=10min
S1309_Severity=Info
S1309_Tags=
S1309_Title=Track uses of in-source issue suppressions
S1309_Type=CODE_SMELL
S131_Category=Sonar Code Smell
S131_Description=The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a suitable comment as to why no action is taken. Even when the switch covers all current values of an enum, a default case should still be used because there is no guarantee that the enum won't be extended.
S131_IsActivatedByDefault=False
S131_Remediation=Constant/Issue
S131_RemediationCost=5min
S131_Severity=Critical
S131_Tags=cwe,misra,cert
S131_Title="switch/Select" statements should end with "default/Case Else" clauses
S131_Type=CODE_SMELL
S1313_Category=Sonar Vulnerability
S1313_Description=Hardcoding an IP address into source code is a bad idea for several reasons:
S1313_IsActivatedByDefault=False
S1313_Remediation=Constant/Issue
S1313_RemediationCost=30min
S1313_Severity=Major
S1313_Tags=cert
S1313_Title=IP addresses should not be hardcoded
S1313_Type=VULNERABILITY
S134_Category=Sonar Code Smell
S134_Description=Nested if, switch, for, foreach, while, do, and try statements are key ingredients for making what's known as "Spaghetti code".
S134_IsActivatedByDefault=False
S134_Remediation=Constant/Issue
S134_RemediationCost=10min
S134_Severity=Critical
S134_Tags=brain-overload
S134_Title=Control flow statements "if", "switch", "for", "foreach", "while", "do"  and "try" should not be nested too deeply
S134_Type=CODE_SMELL
S1449_Category=Sonar Code Smell
S1449_Description=string.ToLower(), ToUpper, IndexOf, LastIndexOf, and Compare are all culture-dependent, as are some (floating point number and DateTime-related) calls to ToString. Fortunately, all have variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default culture, possibly creating problems with international characters.
S1449_IsActivatedByDefault=False
S1449_Remediation=Constant/Issue
S1449_RemediationCost=5min
S1449_Severity=Minor
S1449_Tags=unpredictable,cert
S1449_Title=Culture should be specified for "string" operations
S1449_Type=CODE_SMELL
S1450_Category=Sonar Code Smell
S1450_Description=When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.
S1450_IsActivatedByDefault=True
S1450_Remediation=Constant/Issue
S1450_RemediationCost=5min
S1450_Severity=Minor
S1450_Tags=pitfall
S1450_Title=Private fields only used as local variables in methods should become local variables
S1450_Type=CODE_SMELL
S1451_Category=Sonar Code Smell
S1451_Description=Each source file should start with a header stating file ownership and the license which must be used to distribute the application. 
S1451_IsActivatedByDefault=False
S1451_Remediation=Constant/Issue
S1451_RemediationCost=5min
S1451_Severity=Blocker
S1451_Tags=
S1451_Title=Track lack of copyright and license headers
S1451_Type=CODE_SMELL
S1479_Category=Sonar Code Smell
S1479_Description=When switch statements have large sets of case clauses, it is usually an attempt to map two sets of data. A real map structure would be more readable and maintainable, and should be used instead.
S1479_IsActivatedByDefault=True
S1479_Remediation=Constant/Issue
S1479_RemediationCost=30min
S1479_Severity=Major
S1479_Tags=brain-overload
S1479_Title="switch" statements should not have too many "case" clauses
S1479_Type=CODE_SMELL
S1481_Category=Sonar Code Smell
S1481_Description=If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will not wonder what the variable is used for.
S1481_IsActivatedByDefault=True
S1481_Remediation=Constant/Issue
S1481_RemediationCost=5min
S1481_Severity=Minor
S1481_Tags=unused
S1481_Title=Unused local variables should be removed
S1481_Type=CODE_SMELL
S1541_Category=Sonar Code Smell
S1541_Description=The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.
S1541_IsActivatedByDefault=False
S1541_Remediation=Constant/Issue
S1541_RemediationCost=10min
S1541_Severity=Critical
S1541_Tags=brain-overload
S1541_Title=Methods and properties should not be too complex
S1541_Type=CODE_SMELL
S1643_Category=Sonar Code Smell
S1643_Description=StringBuilder is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.
S1643_IsActivatedByDefault=True
S1643_Remediation=Constant/Issue
S1643_RemediationCost=10min
S1643_Severity=Minor
S1643_Tags=performance
S1643_Title=Strings should not be concatenated using '+' in a loop
S1643_Type=CODE_SMELL
S1656_Category=Sonar Bug
S1656_Description=There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake and some other value or variable was intended for the assignment instead.
S1656_IsActivatedByDefault=True
S1656_Remediation=Constant/Issue
S1656_RemediationCost=3min
S1656_Severity=Major
S1656_Tags=cert
S1656_Title=Variables should not be self-assigned
S1656_Type=BUG
S1659_Category=Sonar Code Smell
S1659_Description=Declaring multiple variable on one line is difficult to read.
S1659_IsActivatedByDefault=False
S1659_Remediation=Constant/Issue
S1659_RemediationCost=2min
S1659_Severity=Minor
S1659_Tags=convention,misra,cert
S1659_Title=Multiple variables should not be declared on the same line
S1659_Type=CODE_SMELL
S1694_Category=Sonar Code Smell
S1694_Description=The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes.
S1694_IsActivatedByDefault=False
S1694_Remediation=Constant/Issue
S1694_RemediationCost=5min
S1694_Severity=Minor
S1694_Tags=convention
S1694_Title=An abstract class should have both abstract and concrete methods
S1694_Type=CODE_SMELL
S1696_Category=Sonar Code Smell
S1696_Description=NullReferenceException should be avoided, not caught. Any situation in which NullReferenceException is explicitly caught can easily be converted to a null test, and any behavior being carried out in the catch block can easily be moved to the "is null" branch of the conditional.
S1696_IsActivatedByDefault=False
S1696_Remediation=Constant/Issue
S1696_RemediationCost=5min
S1696_Severity=Major
S1696_Tags=cwe,error-handling,cert
S1696_Title=NullReferenceException should not be caught
S1696_Type=CODE_SMELL
S1697_Category=Sonar Bug
S1697_Description=When either the equality operator in a null test or the logical operator that follows it is reversed, the code has the appearance of safely null-testing the object before dereferencing it. Unfortunately the effect is just the opposite - the object is null-tested and then dereferenced only if it is null, leading to a guaranteed null pointer dereference.
S1697_IsActivatedByDefault=False
S1697_Remediation=Constant/Issue
S1697_RemediationCost=2min
S1697_Severity=Major
S1697_Tags=
S1697_Title=Short-circuit logic should be used to prevent null pointer dereferences in conditionals
S1697_Type=BUG
S1698_Category=Sonar Code Smell
S1698_Description=Using the equality == and inequality != operators to compare two objects generally works. The operators can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then == resolves to reference equality, which may result in unexpected behavior if implementing classes override Equals. Similarly, when a class overrides Equals, but instances are compared with non-overloaded ==, there is a high chance that value comparison was meant instead of the reference one.
S1698_IsActivatedByDefault=False
S1698_Remediation=Constant/Issue
S1698_RemediationCost=2min
S1698_Severity=Minor
S1698_Tags=cwe,cert,suspicious
S1698_Title="==" should not be used when "Equals" is overridden
S1698_Type=CODE_SMELL
S1699_Category=Sonar Code Smell
S1699_Description=Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.
S1699_IsActivatedByDefault=True
S1699_Remediation=Constant/Issue
S1699_RemediationCost=10min
S1699_Severity=Critical
S1699_Tags=cert,pitfall
S1699_Title=Constructors should only call non-overridable methods
S1699_Type=CODE_SMELL
S1751_Category=Sonar Bug
S1751_Description=Having an unconditional break, return, (@)throw or goto in a loop renders it useless; the loop will only execute once and the loop structure itself is simply wasted keystrokes.
S1751_IsActivatedByDefault=True
S1751_Remediation=Constant/Issue
S1751_RemediationCost=5min
S1751_Severity=Major
S1751_Tags=misra,cert,unused
S1751_Title=Jump statements should not be used unconditionally
S1751_Type=BUG
S1764_Category=Sonar Bug
S1764_Description=Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results, and should be simplified.
S1764_IsActivatedByDefault=True
S1764_Remediation=Constant/Issue
S1764_RemediationCost=2min
S1764_Severity=Major
S1764_Tags=cert
S1764_Title=Identical expressions should not be used on both sides of a binary operator
S1764_Type=BUG
S1848_Category=Sonar Bug
S1848_Description=There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could lead to an unexpected behavior in production.
S1848_IsActivatedByDefault=True
S1848_Remediation=Constant/Issue
S1848_RemediationCost=5min
S1848_Severity=Major
S1848_Tags=
S1848_Title=Objects should not be created to be dropped immediately without being used
S1848_Type=BUG
S1854_Category=Sonar Code Smell
S1854_Description=A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources. Therefore all calculated values should be used.
S1854_IsActivatedByDefault=True
S1854_Remediation=Constant/Issue
S1854_RemediationCost=15min
S1854_Severity=Major
S1854_Tags=cwe,cert,unused
S1854_Title=Dead stores should be removed
S1854_Type=CODE_SMELL
S1858_Category=Sonar Code Smell
S1858_Description=Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly invoking ToString() when the compiler would do it implicitly is also needless code-bloat.
S1858_IsActivatedByDefault=False
S1858_Remediation=Constant/Issue
S1858_RemediationCost=2min
S1858_Severity=Minor
S1858_Tags=finding,clumsy
S1858_Title="ToString()" calls should not be redundant
S1858_Type=CODE_SMELL
S1862_Category=Sonar Bug
S1862_Description=A chain of if/else if statements is evaluated from top to bottom. At most, only one branch will be executed: the first one with a condition that evaluates to true. 
S1862_IsActivatedByDefault=True
S1862_Remediation=Constant/Issue
S1862_RemediationCost=10min
S1862_Severity=Major
S1862_Tags=cert,unused,pitfall
S1862_Title=Related "if/else if" statements should not have the same condition
S1862_Type=BUG
S1871_Category=Sonar Code Smell
S1871_Description=Having two cases in the same switch statement or branches in the same if structure with the same implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an if structure they should be combined, or for a switch, one should fall through to the other.
S1871_IsActivatedByDefault=True
S1871_Remediation=Constant/Issue
S1871_RemediationCost=10min
S1871_Severity=Major
S1871_Tags=design,suspicious
S1871_Title=Two branches in a conditional structure should not have exactly the same implementation
S1871_Type=CODE_SMELL
S1905_Category=Sonar Code Smell
S1905_Description=Unnecessary casting expressions make the code harder to read and understand.
S1905_IsActivatedByDefault=True
S1905_Remediation=Constant/Issue
S1905_RemediationCost=5min
S1905_Severity=Minor
S1905_Tags=redundant,clumsy
S1905_Title=Redundant casts should not be used
S1905_Type=CODE_SMELL
S1939_Category=Sonar Code Smell
S1939_Description=An inheritance list entry is redundant if:
S1939_IsActivatedByDefault=True
S1939_Remediation=Constant/Issue
S1939_RemediationCost=1min
S1939_Severity=Minor
S1939_Tags=clumsy
S1939_Title=Inheritance list should not be redundant
S1939_Type=CODE_SMELL
S1940_Category=Sonar Code Smell
S1940_Description=It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.
S1940_IsActivatedByDefault=True
S1940_Remediation=Constant/Issue
S1940_RemediationCost=2min
S1940_Severity=Minor
S1940_Tags=pitfall
S1940_Title=Boolean checks should not be inverted
S1940_Type=CODE_SMELL
S1944_Category=Sonar Code Smell
S1944_Description=Inappropriate casts are issues that will lead to unexpected behavior or runtime errors, such as InvalidCastExceptions. The compiler will catch bad casts from one class to another, but not bad casts to interfaces. Nor will it catch nullable values that are known to be null but that are cast to their underlying value types anyway.
S1944_IsActivatedByDefault=True
S1944_Remediation=Constant/Issue
S1944_RemediationCost=20min
S1944_Severity=Critical
S1944_Tags=cwe,misra,cert,suspicious
S1944_Title=Inappropriate casts should not be made
S1944_Type=CODE_SMELL
S1994_Category=Sonar Code Smell
S1994_Description=It can be extremely confusing when a for loop's counter is incremented outside of its increment clause. In such cases, the increment should be moved to the loop's increment clause if at all possible.
S1994_IsActivatedByDefault=False
S1994_Remediation=Constant/Issue
S1994_RemediationCost=20min
S1994_Severity=Critical
S1994_Tags=confusing
S1994_Title="for" loop increment clauses should modify the loops' counters
S1994_Type=CODE_SMELL
S2068_Category=Sonar Vulnerability
S2068_Description=Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they're almost guaranteed to end up in the hands of an attacker. This is particularly true for applications that are distributed.
S2068_IsActivatedByDefault=True
S2068_Remediation=Constant/Issue
S2068_RemediationCost=30min
S2068_Severity=Blocker
S2068_Tags=cwe,cert,sans-top25-porous,owasp-a2
S2068_Title=Credentials should not be hard-coded
S2068_Type=VULNERABILITY
S2070_Category=Sonar Vulnerability
S2070_Description=The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to create hash collisions with them. That is, it takes too little computational effort to come up with a different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash value gives an attacker the same access as if he had the originally-hashed value. This applies as well to the other Message-Digest algorithms: MD2, MD4, MD6.
S2070_IsActivatedByDefault=False
S2070_Remediation=Constant/Issue
S2070_RemediationCost=30min
S2070_Severity=Critical
S2070_Tags=cwe,owasp-a6,sans-top25-porous
S2070_Title=SHA-1 and Message-Digest hash algorithms should not be used
S2070_Type=VULNERABILITY
S2114_Category=Sonar Bug
S2114_Description=Passing a collection as an argument to the collection's own method is either an error - some other argument was intended - or simply nonsensical code. 
S2114_IsActivatedByDefault=True
S2114_Remediation=Constant/Issue
S2114_RemediationCost=15min
S2114_Severity=Major
S2114_Tags=
S2114_Title=Collections should not be passed as arguments to their own methods
S2114_Type=BUG
S2123_Category=Sonar Bug
S2123_Description=A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.
S2123_IsActivatedByDefault=True
S2123_Remediation=Constant/Issue
S2123_RemediationCost=5min
S2123_Severity=Major
S2123_Tags=unused
S2123_Title=Values should not be uselessly incremented
S2123_Type=BUG
S2156_Category=Sonar Code Smell
S2156_Description=The difference between private and protected visibility is that child classes can see and use protected members, but they cannot see private ones. Since a sealed class cannot have children, marking its members protected is confusingly pointless.
S2156_IsActivatedByDefault=False
S2156_Remediation=Constant/Issue
S2156_RemediationCost=5min
S2156_Severity=Minor
S2156_Tags=confusing
S2156_Title="sealed" classes should not have "protected" members
S2156_Type=CODE_SMELL
S2178_Category=Sonar Code Smell
S2178_Description=The use of non-short-circuit logic in a boolean context is likely a mistake - one that could cause serious program errors as conditions are evaluated under the wrong circumstances.
S2178_IsActivatedByDefault=True
S2178_Remediation=Constant/Issue
S2178_RemediationCost=5min
S2178_Severity=Blocker
S2178_Tags=cert
S2178_Title=Short-circuit logic should be used in boolean contexts
S2178_Type=CODE_SMELL
S2183_Category=Sonar Bug
S2183_Description=Since an int is a 32-bit variable, shifting by more than +/-31 is confusing at best and an error at worst. Shifting an int by 32 is the same as shifting it by 0, and shifting it by 33 is the same as shifting it by 1.
S2183_IsActivatedByDefault=True
S2183_Remediation=Constant/Issue
S2183_RemediationCost=5min
S2183_Severity=Minor
S2183_Tags=cert
S2183_Title=Ints and longs should not be shifted by zero or more than their number of bits-1
S2183_Type=BUG
S2184_Category=Sonar Bug
S2184_Description=When division is performed on ints, the result will always be an int. You can assign that result to a double, float or decimal with automatic type conversion, but having started as an int, the result will likely not be what you expect. If the result of int division is assigned to a floating-point variable, precision will have been lost before the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.
S2184_IsActivatedByDefault=True
S2184_Remediation=Constant/Issue
S2184_RemediationCost=2min
S2184_Severity=Minor
S2184_Tags=cwe,overflow,sans-top25-risky,misra,cert
S2184_Title=Results of integer division should not be assigned to floating point variables
S2184_Type=BUG
S2187_Category=Sonar Code Smell
S2187_Description=There's no point in having an NUnit TestFixture nor a MSTest TestClass without any test methods (Test or TestCase for NUnit and TestMethod for MSTest). This could lead a maintainer to assume a class is covered by tests even though it is not.
S2187_IsActivatedByDefault=True
S2187_Remediation=Constant/Issue
S2187_RemediationCost=5min
S2187_Severity=Blocker
S2187_Tags=tests,unused,confusing
S2187_Title=TestCases should contain tests
S2187_Type=CODE_SMELL
S2190_Category=Sonar Bug
S2190_Description=Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods invoke each other, or when gotos are used to move between two segments of code. It can be a useful tool, but unless the method includes a provision to break out of the recursion and return, the recursion will continue until the stack overflows and the program crashes.
S2190_IsActivatedByDefault=True
S2190_Remediation=Constant/Issue
S2190_RemediationCost=30min
S2190_Severity=Blocker
S2190_Tags=
S2190_Title=Recursion should not be infinite
S2190_Type=BUG
S2197_Category=Sonar Code Smell
S2197_Description=When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for equality with a positive number (or a negative one) could result in unexpected results. 
S2197_IsActivatedByDefault=False
S2197_Remediation=Constant/Issue
S2197_RemediationCost=5min
S2197_Severity=Critical
S2197_Tags=cert,suspicious
S2197_Title=Modulus results should not be checked for direct equality
S2197_Type=CODE_SMELL
S2201_Category=Sonar Bug
S2201_Description=When the call to a function doesn't have any side effects, what is the point of making the call if the results are ignored? In such case, either the function call is useless and should be dropped or the source code doesn't behave as expected.
S2201_IsActivatedByDefault=True
S2201_Remediation=Constant/Issue
S2201_RemediationCost=10min
S2201_Severity=Major
S2201_Tags=misra,cert
S2201_Title=Return values from functions without side effects should not be ignored
S2201_Type=BUG
S2219_Category=Sonar Code Smell
S2219_Description=To check the type of an object there are several options:
S2219_IsActivatedByDefault=True
S2219_Remediation=Constant/Issue
S2219_RemediationCost=5min
S2219_Severity=Minor
S2219_Tags=clumsy
S2219_Title=Runtime type checking should be simplified
S2219_Type=CODE_SMELL
S2221_Category=Sonar Code Smell
S2221_Description=Catching System.Exception seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types, including the ones that were not intended to be caught. To prevent any misunderstandings, the exception filters should be used. Alternatively each exception type should be in a separate catch block.
S2221_IsActivatedByDefault=False
S2221_Remediation=Constant/Issue
S2221_RemediationCost=15min
S2221_Severity=Minor
S2221_Tags=cwe,error-handling
S2221_Title="Exception" should not be caught when not required by called methods
S2221_Type=CODE_SMELL
S2223_Category=Sonar Code Smell
S2223_Description=A static field that is neither constant nor read-only is not thread-safe. Correctly accessing these fields from different threads needs synchronization with locks. Improper synchronization may lead to unexpected results, thus publicly visible static fields are best suited for storing non-changing data shared by many consumers. To enforce this intent, these fields should be marked readonly or converted to constants.
S2223_IsActivatedByDefault=True
S2223_Remediation=Constant/Issue
S2223_RemediationCost=20min
S2223_Severity=Critical
S2223_Tags=pitfall
S2223_Title=Non-constant static fields should not be visible
S2223_Type=CODE_SMELL
S2225_Category=Sonar Bug
S2225_Description=Calling ToString() on an object should always return a string. Returning null instead contravenes the method's implicit contract.
S2225_IsActivatedByDefault=True
S2225_Remediation=Constant/Issue
S2225_RemediationCost=5min
S2225_Severity=Major
S2225_Tags=cwe,cert
S2225_Title="ToString()" method should not return null
S2225_Type=BUG
S2228_Category=Sonar Vulnerability
S2228_Description=Debug statements are always useful during development. But include them in production code - particularly in code that runs client-side - and you run the risk of inadvertently exposing sensitive information.
S2228_IsActivatedByDefault=False
S2228_Remediation=Constant/Issue
S2228_RemediationCost=5min
S2228_Severity=Minor
S2228_Tags=owasp-a6
S2228_Title=Console logging should not be used
S2228_Type=VULNERABILITY
S2234_Category=Sonar Bug
S2234_Description=When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead to unexpected results.
S2234_IsActivatedByDefault=True
S2234_Remediation=Constant/Issue
S2234_RemediationCost=5min
S2234_Severity=Major
S2234_Tags=
S2234_Title=Parameters should be passed in the correct order
S2234_Type=BUG
S2259_Category=Sonar Bug
S2259_Description=A reference to null should never be dereferenced/accessed. Doing so will cause a NullReferenceException to be thrown. At best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or it could allow an attacker to bypass security measures.
S2259_IsActivatedByDefault=True
S2259_Remediation=Constant/Issue
S2259_RemediationCost=10min
S2259_Severity=Major
S2259_Tags=cwe,cert
S2259_Title=Null pointers should not be dereferenced
S2259_Type=BUG
S2275_Category=Sonar Bug
S2275_Description=Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[]). 
S2275_IsActivatedByDefault=True
S2275_Remediation=Constant/Issue
S2275_RemediationCost=10min
S2275_Severity=Blocker
S2275_Tags=cert,pitfall
S2275_Title=Composite format strings should not lead to unexpected behavior at runtime
S2275_Type=BUG
S2278_Category=Sonar Vulnerability
S2278_Description=According to the US National Institute of Standards and Technology (NIST), the Data Encryption Standard (DES) is no longer considered secure:
S2278_IsActivatedByDefault=True
S2278_Remediation=Constant/Issue
S2278_RemediationCost=20min
S2278_Severity=Blocker
S2278_Tags=cwe,cert,owasp-a6,sans-top25-porous
S2278_Title=Neither DES (Data Encryption Standard) nor DESede (3DES) should be used
S2278_Type=VULNERABILITY
S2290_Category=Sonar Code Smell
S2290_Description=Field-like events are events that do not have explicit add and remove methods. The compiler generates a private delegate field to back the event, as well as generating the implicit add and remove methods.
S2290_IsActivatedByDefault=True
S2290_Remediation=Constant/Issue
S2290_RemediationCost=20min
S2290_Severity=Critical
S2290_Tags=
S2290_Title=Field-like events should not be virtual
S2290_Type=CODE_SMELL
S2291_Category=Sonar Code Smell
S2291_Description=Enumerable.Sum() always executes addition in a checked context, so an OverflowException will be thrown if the value exceeds MaxValue even if an unchecked context was specified. Using an unchecked context anyway represents a misunderstanding of how Sum works.
S2291_IsActivatedByDefault=True
S2291_Remediation=Constant/Issue
S2291_RemediationCost=15min
S2291_Severity=Critical
S2291_Tags=error-handling
S2291_Title=Overflow checking should not be disabled for "Enumerable.Sum"
S2291_Type=CODE_SMELL
S2292_Category=Sonar Code Smell
S2292_Description=Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding cleaner and more readable code.
S2292_IsActivatedByDefault=True
S2292_Remediation=Constant/Issue
S2292_RemediationCost=5min
S2292_Severity=Minor
S2292_Tags=clumsy
S2292_Title=Trivial properties should be auto-implemented
S2292_Type=CODE_SMELL
S2306_Category=Sonar Code Smell
S2306_Description=Since C# 5.0, async and await are contextual keywords. Contextual keywords do have a particular meaning in some contexts, but can still be used as variable names. Keywords, on the other hand, are always reserved, and therefore are not valid variable names. To avoid any confusion though, it is best to not use async and await as identifiers.
S2306_IsActivatedByDefault=True
S2306_Remediation=Constant/Issue
S2306_RemediationCost=5min
S2306_Severity=Blocker
S2306_Tags=pitfall
S2306_Title="async" and "await" should not be used as identifiers
S2306_Type=CODE_SMELL
S2325_Category=Sonar Code Smell
S2325_Description=Class methods and properties that don't access instance data can be static to prevent any misunderstanding about the contract of the method. 
S2325_IsActivatedByDefault=False
S2325_Remediation=Constant/Issue
S2325_RemediationCost=5min
S2325_Severity=Minor
S2325_Tags=pitfall
S2325_Title=Methods and properties that don't access instance data should be static
S2325_Type=CODE_SMELL
S2326_Category=Sonar Code Smell
S2326_Description=Type parameters that aren't used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type parameters should be removed.
S2326_IsActivatedByDefault=True
S2326_Remediation=Constant/Issue
S2326_RemediationCost=5min
S2326_Severity=Major
S2326_Tags=cert,unused
S2326_Title=Unused type parameters should be removed
S2326_Type=CODE_SMELL
S2328_Category=Sonar Bug
S2328_Description=GetHashCode is used to file an object in a Dictionary or Hashtable. If GetHashCode uses non-readonly fields and those fields change after the object is stored, the object immediately becomes mis-filed in the Hashtable. Any subsequent test to see if the object is in the Hashtable will return a false negative.
S2328_IsActivatedByDefault=True
S2328_Remediation=Constant/Issue
S2328_RemediationCost=10min
S2328_Severity=Minor
S2328_Tags=
S2328_Title="GetHashCode" should not reference mutable fields
S2328_Type=BUG
S2330_Category=Sonar Code Smell
S2330_Description=Array covariance is the principle that if an implicit or explicit reference conversion exits from type A to B, then the same conversion exists from the array type A[] to B[].
S2330_IsActivatedByDefault=False
S2330_Remediation=Constant/Issue
S2330_RemediationCost=15min
S2330_Severity=Critical
S2330_Tags=pitfall
S2330_Title=Array covariance should not be used
S2330_Type=CODE_SMELL
S2333_Category=Sonar Code Smell
S2333_Description=Unnecessary keywords simply clutter the code and should be removed. Specifically:
S2333_IsActivatedByDefault=False
S2333_Remediation=Constant/Issue
S2333_RemediationCost=2min
S2333_Severity=Minor
S2333_Tags=unused,finding,clumsy
S2333_Title=Redundant modifiers should not be used
S2333_Type=CODE_SMELL
S2339_Category=Sonar Code Smell
S2339_Description=Constant members are copied at compile time to the call sites, instead of being fetched at runtime.
S2339_IsActivatedByDefault=False
S2339_Remediation=Constant/Issue
S2339_RemediationCost=5min
S2339_Severity=Critical
S2339_Tags=pitfall
S2339_Title=Public constant members should not be used
S2339_Type=CODE_SMELL
S2342_Category=Sonar Code Smell
S2342_Description=Shared naming conventions allow teams to collaborate efficiently. This rule checks that all enum names match a provided regular expression.
S2342_IsActivatedByDefault=True
S2342_Remediation=Constant/Issue
S2342_RemediationCost=5min
S2342_Severity=Minor
S2342_Tags=convention
S2342_Title=Enumeration types should comply with a naming convention
S2342_Type=CODE_SMELL
S2344_Category=Sonar Code Smell
S2344_Description=The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.
S2344_IsActivatedByDefault=True
S2344_Remediation=Constant/Issue
S2344_RemediationCost=5min
S2344_Severity=Minor
S2344_Tags=convention
S2344_Title=Enumeration type names should not have "Flags" or "Enum" suffixes
S2344_Type=CODE_SMELL
S2345_Category=Sonar Bug
S2345_Description=Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization will set the first member to 0, and increment the value by one for each subsequent member. This implicit behavior does not allow members to be combined using the bitwise or operator in a useful way.
S2345_IsActivatedByDefault=True
S2345_Remediation=Constant/Issue
S2345_RemediationCost=5min
S2345_Severity=Minor
S2345_Tags=
S2345_Title=Flags enumerations should explicitly initialize all their members
S2345_Type=BUG
S2346_Category=Sonar Code Smell
S2346_Description=Consistent use of "None" in flags enumerations indicates that all flag values are cleared. The value 0 should not be used to indicate any other state, since there is no way to check that the bit 0 is set.
S2346_IsActivatedByDefault=True
S2346_Remediation=Constant/Issue
S2346_RemediationCost=5min
S2346_Severity=Critical
S2346_Tags=convention
S2346_Title=Flags enumerations zero-value members should be named "None"
S2346_Type=CODE_SMELL
S2357_Category=Sonar Code Smell
S2357_Description=Fields should not be part of an API, and therefore should always be private. Indeed, they cannot be added to an interface for instance, and validation cannot be added later on without breaking backward compatibility. Instead, developers should encapsulate their fields into properties. Explicit property getters and setters can be introduced for validation purposes or to smooth the transition to a newer system.
S2357_IsActivatedByDefault=False
S2357_Remediation=Constant/Issue
S2357_RemediationCost=30min
S2357_Severity=Major
S2357_Tags=pitfall
S2357_Title=Fields should be private
S2357_Type=CODE_SMELL
S2360_Category=Sonar Code Smell
S2360_Description=The overloading mechanism should be used in place of optional parameters for several reasons:
S2360_IsActivatedByDefault=False
S2360_Remediation=Constant/Issue
S2360_RemediationCost=5min
S2360_Severity=Critical
S2360_Tags=pitfall
S2360_Title=Optional parameters should not be used
S2360_Type=CODE_SMELL
S2365_Category=Sonar Code Smell
S2365_Description=Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will be much slower than a simple field access, contrary to the caller's likely expectations. Therefore, such properties should be refactored into methods so that callers are not surprised by unexpectedly poor performance.
S2365_IsActivatedByDefault=True
S2365_Remediation=Constant/Issue
S2365_RemediationCost=5min
S2365_Severity=Critical
S2365_Tags=api-design,performance
S2365_Title=Properties should not make collection or array copies
S2365_Type=CODE_SMELL
S2368_Category=Sonar Code Smell
S2368_Description=Exposing methods with multidimensional array parameters requires developers to have advanced knowledge about the language in order to be able to use them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods should not be exposed, but can be used internally.
S2368_IsActivatedByDefault=True
S2368_Remediation=Constant/Issue
S2368_RemediationCost=1h
S2368_Severity=Blocker
S2368_Tags=pitfall
S2368_Title=Public methods should not have multidimensional array parameters
S2368_Type=CODE_SMELL
S2372_Category=Sonar Code Smell
S2372_Description=Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method. 
S2372_IsActivatedByDefault=True
S2372_Remediation=Constant/Issue
S2372_RemediationCost=20min
S2372_Severity=Major
S2372_Tags=error-handling
S2372_Title=Exceptions should not be thrown from property getters
S2372_Type=CODE_SMELL
S2376_Category=Sonar Code Smell
S2376_Description=Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or the property should be replaced with a setter method.
S2376_IsActivatedByDefault=True
S2376_Remediation=Constant/Issue
S2376_RemediationCost=20min
S2376_Severity=Major
S2376_Tags=pitfall
S2376_Title=Write-only properties should not be used
S2376_Type=CODE_SMELL
S2386_Category=Sonar Vulnerability
S2386_Description=public static mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by reducing the accessibility of the field or by changing the return type to an immutable type.
S2386_IsActivatedByDefault=True
S2386_Remediation=Constant/Issue
S2386_RemediationCost=15min
S2386_Severity=Minor
S2386_Tags=cwe,unpredictable,cert
S2386_Title=Mutable fields should not be "public static"
S2386_Type=VULNERABILITY
S2387_Category=Sonar Code Smell
S2387_Description=Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you'll get confusion at best, chaos at worst. 
S2387_IsActivatedByDefault=False
S2387_Remediation=Constant/Issue
S2387_RemediationCost=5min
S2387_Severity=Blocker
S2387_Tags=confusing
S2387_Title=Child class fields should not shadow parent class fields
S2387_Type=CODE_SMELL
S2436_Category=Sonar Code Smell
S2436_Description=A method or class with too many type parameters has likely aggregated too many responsibilities and should be split.
S2436_IsActivatedByDefault=True
S2436_Remediation=Constant/Issue
S2436_RemediationCost=20min
S2436_Severity=Major
S2436_Tags=brain-overload
S2436_Title=Classes and methods should not have too many generic parameters
S2436_Type=CODE_SMELL
S2437_Category=Sonar Code Smell
S2437_Description=Certain bit operations are just silly and should not be performed because their results are predictable.
S2437_IsActivatedByDefault=True
S2437_Remediation=Constant/Issue
S2437_RemediationCost=5min
S2437_Severity=Blocker
S2437_Tags=suspicious
S2437_Title=Silly bit operations should not be performed
S2437_Type=CODE_SMELL
S2486_Category=Sonar Code Smell
S2486_Description=When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.
S2486_IsActivatedByDefault=True
S2486_Remediation=Constant/Issue
S2486_RemediationCost=1h
S2486_Severity=Minor
S2486_Tags=cwe,error-handling,suspicious
S2486_Title=Generic exceptions should not be ignored
S2486_Type=CODE_SMELL
S2551_Category=Sonar Bug
S2551_Description=Locking on the current object instance (i.e. this), or on a Type object increases the chance of deadlocks because any other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose. 
S2551_IsActivatedByDefault=False
S2551_Remediation=Constant/Issue
S2551_RemediationCost=15min
S2551_Severity=Critical
S2551_Tags=multi-threading
S2551_Title=Types and "this" should not be used for locking
S2551_Type=BUG
S2583_Category=Sonar Bug
S2583_Description=Conditional expressions which are always true or false can lead to dead code. Such code is always buggy and should never be used in production.
S2583_IsActivatedByDefault=True
S2583_Remediation=Constant/Issue
S2583_RemediationCost=15min
S2583_Severity=Major
S2583_Tags=cwe,misra,cert,unused,pitfall
S2583_Title=Conditionally executed blocks should be reachable
S2583_Type=BUG
S2589_Category=Sonar Code Smell
S2589_Description=If a boolean expression doesn't change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous because it does not match the programmer's intent, then it's a bug and the expression should be fixed.
S2589_IsActivatedByDefault=True
S2589_Remediation=Constant/Issue
S2589_RemediationCost=10min
S2589_Severity=Major
S2589_Tags=cwe,misra,cert,redundant
S2589_Title=Boolean expressions should not be gratuitous
S2589_Type=CODE_SMELL
S2674_Category=Sonar Bug
S2674_Description=You cannot assume that any given stream reading call will fill the byte[] passed in to the method with the number of bytes requested. Instead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both harmful and difficult to reproduce.
S2674_IsActivatedByDefault=False
S2674_Remediation=Constant/Issue
S2674_RemediationCost=15min
S2674_Severity=Minor
S2674_Tags=cert
S2674_Title=The length returned from a stream read should be checked
S2674_Type=BUG
S2681_Category=Sonar Bug
S2681_Description=Curly braces can be omitted from a one-line block, such as with an if statement or for loop, but doing so can be misleading and induce bugs. 
S2681_IsActivatedByDefault=True
S2681_Remediation=Constant/Issue
S2681_RemediationCost=5min
S2681_Severity=Major
S2681_Tags=cwe,cert
S2681_Title=Multiline blocks should be enclosed in curly braces
S2681_Type=BUG
S2688_Category=Sonar Bug
S2688_Description=NaN is not equal to anything, even itself. Testing for equality or inequality against NaN will yield predictable results, but probably not the ones you want. 
S2688_IsActivatedByDefault=True
S2688_Remediation=Constant/Issue
S2688_RemediationCost=5min
S2688_Severity=Major
S2688_Tags=cert
S2688_Title="NaN" should not be used in comparisons
S2688_Type=BUG
S2692_Category=Sonar Code Smell
S2692_Description=Most checks against an IndexOf value compare it with -1 because 0 is a valid index. Any checks which look for values >0 ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a value in a string, List, or an array, consider using the Contains method instead.
S2692_IsActivatedByDefault=True
S2692_Remediation=Constant/Issue
S2692_RemediationCost=2min
S2692_Severity=Critical
S2692_Tags=suspicious
S2692_Title="IndexOf" checks should not be for positive numbers
S2692_Type=CODE_SMELL
S2696_Category=Sonar Code Smell
S2696_Description=Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple class instances and/or multiple threads in play. 
S2696_IsActivatedByDefault=True
S2696_Remediation=Constant/Issue
S2696_RemediationCost=20min
S2696_Severity=Critical
S2696_Tags=multi-threading
S2696_Title=Instance members should not write to "static" fields
S2696_Type=CODE_SMELL
S2737_Category=Sonar Code Smell
S2737_Description=A catch clause that only rethrows the caught exception has the same effect as omitting the catch altogether and letting it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads. 
S2737_IsActivatedByDefault=True
S2737_Remediation=Constant/Issue
S2737_RemediationCost=5min
S2737_Severity=Minor
S2737_Tags=cert,unused,finding,clumsy
S2737_Title="catch" clauses should do more than rethrow
S2737_Type=CODE_SMELL
S2743_Category=Sonar Code Smell
S2743_Description=A static field in a generic type is not shared among instances of different closed constructed types, thus LengthLimitedSingletonCollection<int>.instances and LengthLimitedSingletonCollection<string>.instances will point to different objects, even though instances is seemingly shared among all LengthLimitedSingletonCollection<> generic classes.
S2743_IsActivatedByDefault=True
S2743_Remediation=Constant/Issue
S2743_RemediationCost=10min
S2743_Severity=Major
S2743_Tags=
S2743_Title=Static fields should not be used in generic types
S2743_Type=CODE_SMELL
S2757_Category=Sonar Bug
S2757_Description=The use of operators pairs ( =+, =- or =! ) where the reversed, single operator was meant (+=, -= or !=) will compile and run, but not produce the expected results.
S2757_IsActivatedByDefault=True
S2757_Remediation=Constant/Issue
S2757_RemediationCost=2min
S2757_Severity=Major
S2757_Tags=
S2757_Title="=+" should not be used instead of "+="
S2757_Type=BUG
S2758_Category=Sonar Bug
S2758_Description=When the second and third operands of a ternary operator are the same, the operator will always return the same value regardless of the condition. Either the operator itself is pointless, or a mistake was made in coding it. 
S2758_IsActivatedByDefault=True
S2758_Remediation=Constant/Issue
S2758_RemediationCost=5min
S2758_Severity=Major
S2758_Tags=
S2758_Title=The ternary operator should not return the same value regardless of the condition
S2758_Type=BUG
S2760_Category=Sonar Code Smell
S2760_Description=When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should have been checked in the second test.
S2760_IsActivatedByDefault=False
S2760_Remediation=Constant/Issue
S2760_RemediationCost=5min
S2760_Severity=Minor
S2760_Tags=suspicious,clumsy
S2760_Title=Sequential tests should not check the same condition
S2760_Type=CODE_SMELL
S2761_Category=Sonar Bug
S2761_Description=Calling the ! or ~ prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are typically caused by accidentally double-tapping the key in question without noticing.
S2761_IsActivatedByDefault=True
S2761_Remediation=Constant/Issue
S2761_RemediationCost=5min
S2761_Severity=Major
S2761_Tags=
S2761_Title=Doubled prefix operators "!!" and "~~" should not be used
S2761_Type=BUG
S2930_Category=Sonar Bug
S2930_Description=When writing managed code, you don't need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency reasons, some objects such as Bitmap use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have potentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed footprint, and fails to reclaim the unmanaged memory (by calling Bitmap's finalizer method) in a timely fashion. 
S2930_IsActivatedByDefault=True
S2930_Remediation=Constant/Issue
S2930_RemediationCost=10min
S2930_Severity=Blocker
S2930_Tags=cwe,denial-of-service
S2930_Title="IDisposables" should be disposed
S2930_Type=BUG
S2931_Category=Sonar Bug
S2931_Description=Classes with IDisposable members are responsible for cleaning up those members by calling their Dispose methods. The best practice here is for the owning class to itself implement IDisposable and call its members' Dispose methods from its own Dispose method.
S2931_IsActivatedByDefault=False
S2931_Remediation=Constant/Issue
S2931_RemediationCost=10min
S2931_Severity=Blocker
S2931_Tags=cwe,denial-of-service
S2931_Title=Classes with "IDisposable" members should implement "IDisposable"
S2931_Type=BUG
S2933_Category=Sonar Code Smell
S2933_Description=readonly fields can only be assigned in a class constructor. If a class has a field that's not marked readonly but is only set in the constructor, it could cause confusion about the field's intended use. To avoid confusion, such fields should be marked readonly to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use.
S2933_IsActivatedByDefault=True
S2933_Remediation=Constant/Issue
S2933_RemediationCost=2min
S2933_Severity=Major
S2933_Tags=confusing
S2933_Title=Fields that are only assigned in the constructor should be "readonly"
S2933_Type=CODE_SMELL
S2934_Category=Sonar Bug
S2934_Description=While the properties of a readonly reference type field can still be changed after initialization, those of a readonly value field, such as a struct, cannot. 
S2934_IsActivatedByDefault=True
S2934_Remediation=Constant/Issue
S2934_RemediationCost=20min
S2934_Severity=Minor
S2934_Tags=
S2934_Title=Property assignments should not be made for "readonly" fields not constrained to reference types
S2934_Type=BUG
S2952_Category=Sonar Bug
S2952_Description=It is possible in an IDisposable to call Dispose on class members from any method, but the contract of Dispose is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource leaks.
S2952_IsActivatedByDefault=False
S2952_Remediation=Constant/Issue
S2952_RemediationCost=20min
S2952_Severity=Critical
S2952_Tags=cwe,denial-of-service
S2952_Title=Classes should "Dispose" of members from the classes' own "Dispose" methods
S2952_Type=BUG
S2953_Category=Sonar Code Smell
S2953_Description=Dispose as a method name should be used exclusively to implement IDisposable.Dispose to prevent any confusion.
S2953_IsActivatedByDefault=True
S2953_Remediation=Constant/Issue
S2953_RemediationCost=10min
S2953_Severity=Blocker
S2953_Tags=pitfall
S2953_Title=Methods named "Dispose" should implement "IDisposable.Dispose"
S2953_Type=CODE_SMELL
S2955_Category=Sonar Bug
S2955_Description=When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a struct, could also be passed. In such cases, comparing the type parameter to null would always be false, because a struct can be empty, but never null. If a value type is truly what's expected, then the comparison should use default(). If it's not, then constraints should be added so that no value type can be passed.
S2955_IsActivatedByDefault=False
S2955_Remediation=Constant/Issue
S2955_RemediationCost=10min
S2955_Severity=Minor
S2955_Tags=
S2955_Title=Generic parameters not constrained to reference types should not be compared to "null"
S2955_Type=BUG
S2971_Category=Sonar Code Smell
S2971_Description=In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways IEnumerable LINQs can be simplified
S2971_IsActivatedByDefault=True
S2971_Remediation=Constant/Issue
S2971_RemediationCost=5min
S2971_Severity=Major
S2971_Tags=clumsy
S2971_Title="IEnumerable" LINQs should be simplified
S2971_Type=CODE_SMELL
S2995_Category=Sonar Bug
S2995_Description=Using Object.ReferenceEquals to compare the references of two value types simply won't return the expected results most of the time because such types are passed by value, not by reference.
S2995_IsActivatedByDefault=True
S2995_Remediation=Constant/Issue
S2995_RemediationCost=15min
S2995_Severity=Major
S2995_Tags=
S2995_Title="Object.ReferenceEquals" should not be used for value types
S2995_Type=BUG
S2996_Category=Sonar Bug
S2996_Description=When an object has a field annotated with ThreadStatic, that field is shared within a given thread, but unique across threads. Since a class' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial values.
S2996_IsActivatedByDefault=True
S2996_Remediation=Constant/Issue
S2996_RemediationCost=20min
S2996_Severity=Major
S2996_Tags=multi-threading
S2996_Title="ThreadStatic" fields should not be initialized
S2996_Type=BUG
S2997_Category=Sonar Bug
S2997_Description=Typically you want to use using to create a local IDisposable variable; it will trigger disposal of the object when control passes out of the block's scope. The exception to this rule is when your method returns that IDisposable. In that case using disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove using or avoid returning the IDisposable.
S2997_IsActivatedByDefault=True
S2997_Remediation=Constant/Issue
S2997_RemediationCost=5min
S2997_Severity=Major
S2997_Tags=
S2997_Title="IDisposables" created in a "using" statement should not be returned
S2997_Type=BUG
S3005_Category=Sonar Bug
S3005_Description=When a non-static class field is annotated with ThreadStatic, the code seems to show that the field can have different values for different calling threads, but that's not the case, since the ThreadStatic attribute is simply ignored on non-static fields. 
S3005_IsActivatedByDefault=True
S3005_Remediation=Constant/Issue
S3005_RemediationCost=5min
S3005_Severity=Major
S3005_Tags=unused
S3005_Title="ThreadStatic" should not be used on non-static fields
S3005_Type=BUG
S3010_Category=Sonar Bug
S3010_Description=Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all instances of the class.
S3010_IsActivatedByDefault=True
S3010_Remediation=Constant/Issue
S3010_RemediationCost=20min
S3010_Severity=Major
S3010_Tags=
S3010_Title=Static fields should not be updated in constructors
S3010_Type=BUG
S3052_Category=Sonar Code Smell
S3052_Description=The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it's considered poor style to do so.
S3052_IsActivatedByDefault=False
S3052_Remediation=Constant/Issue
S3052_RemediationCost=2min
S3052_Severity=Minor
S3052_Tags=convention,finding
S3052_Title=Members should not be initialized to default values
S3052_Type=CODE_SMELL
S3168_Category=Sonar Bug
S3168_Description=An async method with a void return type is a "fire and forget" method best reserved for event handlers because there's no way to wait for the method's execution to complete and respond accordingly. There's also no way to catch exceptions thrown from the method.
S3168_IsActivatedByDefault=True
S3168_Remediation=Constant/Issue
S3168_RemediationCost=15min
S3168_Severity=Major
S3168_Tags=multi-threading
S3168_Title="async" methods should not return "void"
S3168_Type=BUG
S3169_Category=Sonar Code Smell
S3169_Description=There's no point in chaining multiple OrderBy calls in a LINQ; only the last one will be reflected in the result because each subsequent call completely reorders the list. Thus, calling OrderBy multiple times is a performance issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept.
S3169_IsActivatedByDefault=True
S3169_Remediation=Constant/Issue
S3169_RemediationCost=5min
S3169_Severity=Major
S3169_Tags=performance
S3169_Title=Multiple "OrderBy" calls should not be used
S3169_Type=CODE_SMELL
S3172_Category=Sonar Bug
S3172_Description=In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.
S3172_IsActivatedByDefault=True
S3172_Remediation=Constant/Issue
S3172_RemediationCost=30min
S3172_Severity=Major
S3172_Tags=
S3172_Title=Delegates should not be subtracted
S3172_Type=BUG
S3215_Category=Sonar Code Smell
S3215_Description=Needing to cast from an interface to a concrete type indicates that something is wrong with the abstractions in use, likely that something is missing from the interface. Instead of casting to a discrete type, the missing functionality should be added to the interface. Otherwise there is a risk of runtime exceptions.
S3215_IsActivatedByDefault=False
S3215_Remediation=Constant/Issue
S3215_RemediationCost=1h
S3215_Severity=Critical
S3215_Tags=design
S3215_Title="interface" instances should not be cast to concrete types
S3215_Type=CODE_SMELL
S3216_Category=Sonar Code Smell
S3216_Description=After an awaited Task has executed, you can continue execution in the original, calling thread or any arbitrary thread. Unless the rest of the code needs the context from which the Task was spawned, Task.ConfigureAwait(false) should be used to keep execution in the Task thread to avoid the need for context switching and the possibility of deadlocks.
S3216_IsActivatedByDefault=False
S3216_Remediation=Constant/Issue
S3216_RemediationCost=15min
S3216_Severity=Critical
S3216_Tags=multi-threading,suspicious
S3216_Title="ConfigureAwait(false)" should be used
S3216_Type=CODE_SMELL
S3217_Category=Sonar Code Smell
S3217_Description=The foreach statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections available at that time such as ArrayList. The foreach statements allows you to downcast elements of a collection of Objects to any other type. The problem is that to achieve the cast, the foreach statements silently performs explicit type conversion, which at runtime can result in an InvalidCastException.
S3217_IsActivatedByDefault=True
S3217_Remediation=Constant/Issue
S3217_RemediationCost=15min
S3217_Severity=Critical
S3217_Tags=suspicious
S3217_Title="Explicit" conversions of "foreach" loops should not be used
S3217_Type=CODE_SMELL
S3218_Category=Sonar Code Smell
S3218_Description=It's possible to name the members of an inner class the same as the static members of its enclosing class - possible, but a bad idea. That's because maintainers may be confused about which members are being used where. Instead the inner class' members should be renamed and all the references updated.
S3218_IsActivatedByDefault=True
S3218_Remediation=Constant/Issue
S3218_RemediationCost=10min
S3218_Severity=Critical
S3218_Tags=design,cert,pitfall
S3218_Title=Inner class members should not shadow outer class "static" or type members
S3218_Type=CODE_SMELL
S3220_Category=Sonar Code Smell
S3220_Description=The rules for method resolution are complex and perhaps not properly understood by all coders. The params keyword can make method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods.
S3220_IsActivatedByDefault=True
S3220_Remediation=Constant/Issue
S3220_RemediationCost=20min
S3220_Severity=Minor
S3220_Tags=pitfall
S3220_Title=Method calls should not resolve ambiguously to overloads with "params"
S3220_Type=CODE_SMELL
S3234_Category=Sonar Code Smell
S3234_Description=GC.SuppressFinalize asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the dispose pattern where object finalization is already handled in IDisposable.Dispose. However, it has no effect if there is no finalizer defined in the object's type, so using it in such cases is just confusing.
S3234_IsActivatedByDefault=False
S3234_Remediation=Constant/Issue
S3234_RemediationCost=2min
S3234_Severity=Minor
S3234_Tags=unused,confusing
S3234_Title="GC.SuppressFinalize" should not be invoked for types without destructors
S3234_Type=CODE_SMELL
S3235_Category=Sonar Code Smell
S3235_Description=Redundant parentheses are simply wasted keystrokes, and should be removed.
S3235_IsActivatedByDefault=False
S3235_Remediation=Constant/Issue
S3235_RemediationCost=2min
S3235_Severity=Minor
S3235_Tags=cert,unused,finding
S3235_Title=Redundant parentheses should not be used
S3235_Type=CODE_SMELL
S3236_Category=Sonar Code Smell
S3236_Description=Caller information attributes: CallerFilePathAttribute and CallerLineNumberAttribute provide a way to get information about the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes.
S3236_IsActivatedByDefault=True
S3236_Remediation=Constant/Issue
S3236_RemediationCost=2min
S3236_Severity=Minor
S3236_Tags=suspicious
S3236_Title=Caller information arguments should not be provided explicitly
S3236_Type=CODE_SMELL
S3237_Category=Sonar Code Smell
S3237_Description=In property and indexer set methods, and in event add and remove methods, the implicit value parameter holds the value the accessor was called with. Not using the value means that the accessor ignores the caller's intent which could cause unexpected results at runtime.
S3237_IsActivatedByDefault=True
S3237_Remediation=Constant/Issue
S3237_RemediationCost=5min
S3237_Severity=Blocker
S3237_Tags=pitfall
S3237_Title="value" parameters should be used
S3237_Type=CODE_SMELL
S3240_Category=Sonar Code Smell
S3240_Description=In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means 
S3240_IsActivatedByDefault=False
S3240_Remediation=Constant/Issue
S3240_RemediationCost=2min
S3240_Severity=Minor
S3240_Tags=clumsy
S3240_Title=The simplest possible condition syntax should be used
S3240_Type=CODE_SMELL
S3241_Category=Sonar Code Smell
S3241_Description=Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their callers, then clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity. 
S3241_IsActivatedByDefault=True
S3241_Remediation=Constant/Issue
S3241_RemediationCost=2min
S3241_Severity=Minor
S3241_Tags=design,cert,unused
S3241_Title=Methods should not return values that are never used
S3241_Type=CODE_SMELL
S3242_Category=Sonar Code Smell
S3242_Description=When a derived type is used as a parameter instead of the base type, it limits the uses of the method. If the additional functionality that is provided in the derived type is not requires then that limitation isn't required, and should be removed.
S3242_IsActivatedByDefault=True
S3242_Remediation=Constant/Issue
S3242_RemediationCost=5min
S3242_Severity=Minor
S3242_Tags=api-design
S3242_Title=Method parameters should be declared with base types
S3242_Type=CODE_SMELL
S3244_Category=Sonar Bug
S3244_Description=It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That's because the process of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove this item from the subscription list. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added. The result: NOOP.
S3244_IsActivatedByDefault=True
S3244_Remediation=Constant/Issue
S3244_RemediationCost=15min
S3244_Severity=Major
S3244_Tags=
S3244_Title=Anonymous delegates should not be used to unsubscribe from Events
S3244_Type=BUG
S3246_Category=Sonar Code Smell
S3246_Description=In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and in modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively.
S3246_IsActivatedByDefault=True
S3246_Remediation=Constant/Issue
S3246_RemediationCost=5min
S3246_Severity=Major
S3246_Tags=api-design
S3246_Title=Generic type parameters should be co/contravariant when possible
S3246_Type=CODE_SMELL
S3247_Category=Sonar Code Smell
S3247_Description=Because the is operator performs a cast if the object is not null, using is to check type and then casting the same argument to that type, necessarily performs two casts. The same result can be achieved more efficiently with a single cast using as, followed by a null-check.
S3247_IsActivatedByDefault=True
S3247_Remediation=Constant/Issue
S3247_RemediationCost=10min
S3247_Severity=Minor
S3247_Tags=performance
S3247_Title=Duplicate casts should not be made
S3247_Type=CODE_SMELL
S3249_Category=Sonar Bug
S3249_Description=Making a base call in an overriding method is generally a good idea, but not in GetHashCode and Equals for classes that directly extend object because those methods are based on the object reference. Meaning that no two objects that use those base methods will ever be equal or have the same hash.
S3249_IsActivatedByDefault=True
S3249_Remediation=Constant/Issue
S3249_RemediationCost=15min
S3249_Severity=Major
S3249_Tags=
S3249_Title=Classes directly extending "object" should not call "base" in "GetHashCode" or "Equals"
S3249_Type=BUG
S3251_Category=Sonar Code Smell
S3251_Description=partial methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking methods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to production, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are critical, missing functionality, the loss of which will lead to unexpected results at runtime.
S3251_IsActivatedByDefault=True
S3251_Remediation=Constant/Issue
S3251_RemediationCost=20min
S3251_Severity=Minor
S3251_Tags=suspicious
S3251_Title=Implementations should be provided for "partial" methods
S3251_Type=CODE_SMELL
S3253_Category=Sonar Code Smell
S3253_Description=Since the compiler will automatically invoke the base type's no-argument constructor, there's no need to specify its invocation explicitly. Also, when only a single public parameterless constructor is defined in a class, then that constructor can be removed because the compiler would generate it automatically. Similarly, empty static constructors and empty destructors are also wasted keystrokes.
S3253_IsActivatedByDefault=False
S3253_Remediation=Constant/Issue
S3253_RemediationCost=2min
S3253_Severity=Minor
S3253_Tags=finding,clumsy
S3253_Title=Constructor and destructor declarations should not be redundant
S3253_Type=CODE_SMELL
S3254_Category=Sonar Code Smell
S3254_Description=Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.
S3254_IsActivatedByDefault=False
S3254_Remediation=Constant/Issue
S3254_RemediationCost=2min
S3254_Severity=Minor
S3254_Tags=finding,clumsy
S3254_Title=Default parameter values should not be passed as arguments
S3254_Type=CODE_SMELL
S3256_Category=Sonar Code Smell
S3256_Description=Using string.Equals to determine if a string is empty is significantly slower than using string.IsNullOrEmpty() or checking for string.Length == 0. string.IsNullOrEmpty() is both clear and concise, and therefore preferred to laborious, error-prone, manual null- and emptiness-checking.
S3256_IsActivatedByDefault=True
S3256_Remediation=Constant/Issue
S3256_RemediationCost=5min
S3256_Severity=Minor
S3256_Tags=clumsy
S3256_Title="string.IsNullOrEmpty" should be used
S3256_Type=CODE_SMELL
S3257_Category=Sonar Code Smell
S3257_Description=Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified.
S3257_IsActivatedByDefault=False
S3257_Remediation=Constant/Issue
S3257_RemediationCost=1min
S3257_Severity=Minor
S3257_Tags=finding,clumsy
S3257_Title=Declarations and initializations should be as concise as possible
S3257_Type=CODE_SMELL
S3261_Category=Sonar Code Smell
S3261_Description=Namespaces with no lines of code clutter a project and should be removed. 
S3261_IsActivatedByDefault=True
S3261_Remediation=Constant/Issue
S3261_RemediationCost=2min
S3261_Severity=Minor
S3261_Tags=cert,unused
S3261_Title=Namespaces should not be empty
S3261_Type=CODE_SMELL
S3262_Category=Sonar Code Smell
S3262_Description=Overriding methods automatically inherit the params behavior. To ease readability, this modifier should be explicitly used in the overriding method as well.
S3262_IsActivatedByDefault=True
S3262_Remediation=Constant/Issue
S3262_RemediationCost=2min
S3262_Severity=Major
S3262_Tags=confusing
S3262_Title="params" should be used on overrides
S3262_Type=CODE_SMELL
S3263_Category=Sonar Bug
S3263_Description=Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class above the field or fields required for its initialization will yield unexpected results.
S3263_IsActivatedByDefault=True
S3263_Remediation=Constant/Issue
S3263_RemediationCost=5min
S3263_Severity=Major
S3263_Tags=
S3263_Title=Static fields should appear in the order they must be initialized 
S3263_Type=BUG
S3264_Category=Sonar Code Smell
S3264_Description=Events that are not invoked anywhere are dead code, and there's no good reason to keep them in the source.
S3264_IsActivatedByDefault=True
S3264_Remediation=Constant/Issue
S3264_RemediationCost=10min
S3264_Severity=Major
S3264_Tags=unused
S3264_Title=Events should be invoked
S3264_Type=CODE_SMELL
S3265_Category=Sonar Code Smell
S3265_Description=enums are usually used to identify distinct elements in a set of values. However enums can be treated as bit fields and bitwise operations can be used on them to combine the values. This is a good way of specifying multiple elements of set with a single value. When enums are used this way, it is a best practice to mark the enum with the FlagsAttribute.
S3265_IsActivatedByDefault=True
S3265_Remediation=Constant/Issue
S3265_RemediationCost=2min
S3265_Severity=Critical
S3265_Tags=convention
S3265_Title=Non-flags enums should not be used in bitwise operations
S3265_Type=CODE_SMELL
S3346_Category=Sonar Bug
S3346_Description=An assertion is a piece of code that's used during development when the compilation debug mode is activated. It allows a program to check itself as it runs. When an assertion is true, that means everything is operating as expected. 
S3346_IsActivatedByDefault=True
S3346_Remediation=Constant/Issue
S3346_RemediationCost=5min
S3346_Severity=Major
S3346_Tags=cert
S3346_Title=Expressions used in "Debug.Assert" should not produce side effects
S3346_Type=BUG
S3376_Category=Sonar Code Smell
S3376_Description=Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, class FirstAttribute : Attribute can be used simply with First, but you must use the full name for class AttributeOne : Attribute.
S3376_IsActivatedByDefault=True
S3376_Remediation=Constant/Issue
S3376_RemediationCost=5min
S3376_Severity=Minor
S3376_Tags=convention
S3376_Title=Attribute, EventArgs, and Exception type names should end with the type being extended
S3376_Type=CODE_SMELL
S3397_Category=Sonar Bug
S3397_Description=object.Equals() overrides can be optimized by checking first for reference equality between this and the parameter. This check can be implemented by calling object.ReferenceEquals() or base.Equals(), where base is object. However, using base.Equals() is a maintenance hazard because while it works if you extend Object directly, if you introduce a new base class that overrides Equals, it suddenly stops working.
S3397_IsActivatedByDefault=True
S3397_Remediation=Constant/Issue
S3397_RemediationCost=5min
S3397_Severity=Minor
S3397_Tags=
S3397_Title="base.Equals" should not be used to check for reference equality in "Equals" if "base" is not "object"
S3397_Type=BUG
S3427_Category=Sonar Code Smell
S3427_Description=The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with optional parameter values makes the matter even harder to understand. 
S3427_IsActivatedByDefault=True
S3427_Remediation=Constant/Issue
S3427_RemediationCost=10min
S3427_Severity=Blocker
S3427_Tags=unused,pitfall
S3427_Title=Method overloads with default parameter values should not overlap 
S3427_Type=CODE_SMELL
S3431_Category=Sonar Code Smell
S3431_Description=It should be clear to a casual reader what code a test is testing and what results are expected. Unfortunately, that's not usually the case with the [ExpectedException] attribute since an exception could be thrown from almost any line in the method.
S3431_IsActivatedByDefault=False
S3431_Remediation=Constant/Issue
S3431_RemediationCost=5min
S3431_Severity=Major
S3431_Tags=tests
S3431_Title="[ExpectedException]" should not be used
S3431_Type=CODE_SMELL
S3433_Category=Sonar Code Smell
S3433_Description=A method is detected as test method if marked with one of the following attributes [TestMethod] (for mstest), [Fact] (for xunit) or [Test] (for nunit). However, whether or not they have a test attribute, non-public methods are not recognized as tests, and therefore not executed. Neither are async void methods, or methods with generics anywhere in their signatures. 
S3433_IsActivatedByDefault=True
S3433_Remediation=Constant/Issue
S3433_RemediationCost=2min
S3433_Severity=Blocker
S3433_Tags=tests
S3433_Title=Test method signatures should be correct
S3433_Type=CODE_SMELL
S3440_Category=Sonar Code Smell
S3440_Description=There's no point in checking a variable against the value you're about to assign it. Save the cycles and lines of code, and simply perform the assignment.
S3440_IsActivatedByDefault=True
S3440_Remediation=Constant/Issue
S3440_RemediationCost=2min
S3440_Severity=Minor
S3440_Tags=confusing
S3440_Title=Variables should not be checked against the values they're about to be assigned
S3440_Type=CODE_SMELL
S3441_Category=Sonar Code Smell
S3441_Description=When an anonymous type's properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type's property name and the assignment operator.
S3441_IsActivatedByDefault=False
S3441_Remediation=Constant/Issue
S3441_RemediationCost=2min
S3441_Severity=Minor
S3441_Tags=finding,clumsy
S3441_Title=Redundant property names should be omitted in anonymous classes
S3441_Type=CODE_SMELL
S3442_Category=Sonar Code Smell
S3442_Description=Since abstract classes can't be instantiated, there's no point in their having public or internal constructors. If there is basic initialization logic that should run when an extending class instance is created, you can by all means put it in a constructor, but make that constructor private or protected.
S3442_IsActivatedByDefault=True
S3442_Remediation=Constant/Issue
S3442_RemediationCost=2min
S3442_Severity=Major
S3442_Tags=confusing
S3442_Title="abstract" classes should not have "public" constructors
S3442_Type=CODE_SMELL
S3443_Category=Sonar Code Smell
S3443_Description=If you call GetType() on a Type variable, the return value will always be typeof(System.Type). So there's no real point in making that call. The same applies to passing a type argument to IsInstanceOfType. In both cases the results are entirely predictable.
S3443_IsActivatedByDefault=True
S3443_Remediation=Constant/Issue
S3443_RemediationCost=5min
S3443_Severity=Blocker
S3443_Tags=suspicious
S3443_Title=Type should not be examined on "System.Type" instances
S3443_Type=CODE_SMELL
S3444_Category=Sonar Code Smell
S3444_Description=When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived interface will result in the compiler error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'.
S3444_IsActivatedByDefault=True
S3444_Remediation=Constant/Issue
S3444_RemediationCost=5min
S3444_Severity=Minor
S3444_Tags=design
S3444_Title=Interfaces should not simply inherit from base interfaces with colliding members
S3444_Type=CODE_SMELL
S3445_Category=Sonar Code Smell
S3445_Description=When rethrowing an exception, you should do it by simply calling throw; and not throw exc;, because the stack trace is reset with the second syntax, making debugging a lot harder.
S3445_IsActivatedByDefault=True
S3445_Remediation=Constant/Issue
S3445_RemediationCost=2min
S3445_Severity=Major
S3445_Tags=error-handling,confusing
S3445_Title=Exceptions should not be explicitly rethrown
S3445_Type=CODE_SMELL
S3447_Category=Sonar Code Smell
S3447_Description=The use of ref or out in combination with [Optional] is both confusing and contradictory. [Optional] indicates that the parameter doesn't have to be provided, while out and ref mean that the parameter will be used to return data to the caller (ref additionally indicates that the parameter may also be used to pass data into the method).
S3447_IsActivatedByDefault=True
S3447_Remediation=Constant/Issue
S3447_RemediationCost=2min
S3447_Severity=Critical
S3447_Tags=pitfall
S3447_Title="[Optional]" should not be used on "ref" or "out" parameters
S3447_Type=CODE_SMELL
S3449_Category=Sonar Bug
S3449_Description=Numbers can be shifted with the << and >> operators, but the right operand of the operation needs to be an int or a type that has an implicit conversion to int. However, with dynamic, the compiler's type checking is turned off, so you can pass anything to a shift operator and have it compile. And if the argument can't be converted to int at runtime, then a RuntimeBinderException will be raised.
S3449_IsActivatedByDefault=True
S3449_Remediation=Constant/Issue
S3449_RemediationCost=10min
S3449_Severity=Critical
S3449_Tags=
S3449_Title=Right operands of shift operators should be integers
S3449_Type=BUG
S3450_Category=Sonar Code Smell
S3450_Description=There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus, [DefaultParameterValue] should always be used in conjunction with [Optional].
S3450_IsActivatedByDefault=True
S3450_Remediation=Constant/Issue
S3450_RemediationCost=2min
S3450_Severity=Minor
S3450_Tags=pitfall
S3450_Title=Parameters with "[DefaultParameterValue]" attributes should also be marked "[Optional]"
S3450_Type=CODE_SMELL
S3451_Category=Sonar Code Smell
S3451_Description=The use of [DefaultValue] with [Optional] has no more effect than [Optional] alone. That's because [DefaultValue] doesn't actually do anything; it merely indicates the intent for the value. More than likely, [DefaultValue] was used in confusion instead of [DefaultParameterValue].
S3451_IsActivatedByDefault=True
S3451_Remediation=Constant/Issue
S3451_RemediationCost=2min
S3451_Severity=Critical
S3451_Tags=suspicious
S3451_Title="[DefaultValue]" should not be used when "[DefaultParameterValue]" is meant
S3451_Type=CODE_SMELL
S3453_Category=Sonar Bug
S3453_Description=A class with only private constructors can't be instantiated, thus, it seems to be pointless code.
S3453_IsActivatedByDefault=True
S3453_Remediation=Constant/Issue
S3453_RemediationCost=5min
S3453_Severity=Major
S3453_Tags=design
S3453_Title=Classes should not have only "private" constructors
S3453_Type=BUG
S3456_Category=Sonar Bug
S3456_Description=ToCharArray can be omitted when the operation on the array could have been done directly on the string, such as when iterating over the characters in a string, and when accessing a character in a string via an array index. In those cases, explicit ToCharArray calls should be omitted.
S3456_IsActivatedByDefault=True
S3456_Remediation=Constant/Issue
S3456_RemediationCost=2min
S3456_Severity=Minor
S3456_Tags=clumsy
S3456_Title="string.ToCharArray()" should not be called redundantly
S3456_Type=BUG
S3457_Category=Sonar Code Smell
S3457_Description=Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[]). 
S3457_IsActivatedByDefault=True
S3457_Remediation=Constant/Issue
S3457_RemediationCost=10min
S3457_Severity=Major
S3457_Tags=cert,confusing
S3457_Title=Composite format strings should be used correctly
S3457_Type=CODE_SMELL
S3458_Category=Sonar Code Smell
S3458_Description=Empty case clauses that fall through to the default are useless. Whether or not such a case is present, the default clause will be invoked. Such cases simply clutter the code, and should be removed.
S3458_IsActivatedByDefault=True
S3458_Remediation=Constant/Issue
S3458_RemediationCost=1min
S3458_Severity=Minor
S3458_Tags=finding,clumsy
S3458_Title=Empty "case" clauses that fall through to the "default" should be omitted
S3458_Type=CODE_SMELL
S3459_Category=Sonar Code Smell
S3459_Description=Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely, mistakes. 
S3459_IsActivatedByDefault=True
S3459_Remediation=Constant/Issue
S3459_RemediationCost=5min
S3459_Severity=Minor
S3459_Tags=suspicious
S3459_Title=Unassigned members should be removed
S3459_Type=CODE_SMELL
S3466_Category=Sonar Bug
S3466_Description=Generally, writing the least code that will readably do the job is a good thing, so omitting default parameter values seems to make sense. Unfortunately, when you omit them from the base call in an override, you're not actually getting the job done thoroughly, because you're ignoring the value the caller passed in. The result will likely not be what the caller expected.
S3466_IsActivatedByDefault=True
S3466_Remediation=Constant/Issue
S3466_RemediationCost=5min
S3466_Severity=Major
S3466_Tags=
S3466_Title=Optional parameters should be passed to "base" calls
S3466_Type=BUG
S3532_Category=Sonar Code Smell
S3532_Description=The default clause should take appropriate action. Having an empty default is a waste of keystrokes.
S3532_IsActivatedByDefault=False
S3532_Remediation=Constant/Issue
S3532_RemediationCost=	1min
S3532_Severity=Minor
S3532_Tags=unused,finding,clumsy
S3532_Title=Empty "default" clauses should be removed
S3532_Type=CODE_SMELL
S3597_Category=Sonar Code Smell
S3597_Description=The ServiceContract attribute specifies that a class or interface defines the communication contract of a Windows Communication Foundation (WCF) service. The service operations of this class or interface are defined by OperationContract attributes added to methods. It doesn't make sense to define a contract without any service operations; thus, in a ServiceContract class or interface at least one method should be annotated with OperationContract. Similarly, WCF only serves OperationContract methods that are defined inside ServiceContract classes or interfaces; thus, this rule also checks that ServiceContract is added to the containing type of OperationContract methods.
S3597_IsActivatedByDefault=True
S3597_Remediation=Constant/Issue
S3597_RemediationCost=2min
S3597_Severity=Major
S3597_Tags=api-design
S3597_Title="ServiceContract" and "OperationContract" attributes should be used together
S3597_Type=CODE_SMELL
S3598_Category=Sonar Bug
S3598_Description=When declaring a Windows Communication Foundation (WCF) OperationContract method one-way, that service method won't return any result, not even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return type therefore does not make sense.
S3598_IsActivatedByDefault=True
S3598_Remediation=Constant/Issue
S3598_RemediationCost=15min
S3598_Severity=Major
S3598_Tags=
S3598_Title=One-way "OperationContract" methods should have "void" return type
S3598_Type=BUG
S3600_Category=Sonar Code Smell
S3600_Description=Adding params to a method override has no effect. The compiler accepts it, but the callers won't be able to benefit from the added modifier.
S3600_IsActivatedByDefault=True
S3600_Remediation=Constant/Issue
S3600_RemediationCost=1min
S3600_Severity=Critical
S3600_Tags=confusing
S3600_Title="params" should not be introduced on overrides
S3600_Type=CODE_SMELL
S3603_Category=Sonar Bug
S3603_Description=Marking a method with the [Pure] attribute specifies that the method doesn't make any visible changes; thus, the method should return a result, otherwise the call to the method should be equal to no-operation. So [Pure] on a void method is either a mistake, or the method doesn't do any meaningful task.
S3603_IsActivatedByDefault=True
S3603_Remediation=Constant/Issue
S3603_RemediationCost=5min
S3603_Severity=Major
S3603_Tags=
S3603_Title=Methods with "Pure" attribute should return a value 
S3603_Type=BUG
S3604_Category=Sonar Code Smell
S3604_Description=Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same time is redundant; the inline initialization will be overridden.
S3604_IsActivatedByDefault=True
S3604_Remediation=Constant/Issue
S3604_RemediationCost=1min
S3604_Severity=Minor
S3604_Tags=
S3604_Title=Member initializer values should not be redundant
S3604_Type=CODE_SMELL
S3610_Category=Sonar Bug
S3610_Description=Calling GetType() on a nullable object returns the underlying value type. Thus, comparing the returned Type object to typeof(Nullable<SomeType>) doesn't make sense. The comparison either throws an exception or the result can be known at compile time.
S3610_IsActivatedByDefault=True
S3610_Remediation=Constant/Issue
S3610_RemediationCost=5min
S3610_Severity=Major
S3610_Tags=redundant
S3610_Title=Nullable type comparison should not be redundant
S3610_Type=BUG
S3626_Category=Sonar Code Smell
S3626_Description=Jump statements, such as return, yield break, goto, and continue let you change the default flow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.
S3626_IsActivatedByDefault=True
S3626_Remediation=Constant/Issue
S3626_RemediationCost=1min
S3626_Severity=Minor
S3626_Tags=finding,redundant,clumsy
S3626_Title=Jump statements should not be redundant
S3626_Type=CODE_SMELL
S3649_Category=Sonar Vulnerability
S3649_Description=Applications that execute SQL commands should neutralize any externally-provided values used in those commands. Failure to do so could allow an attacker to include input that changes the query so that unintended commands are executed, or sensitive data is exposed.
S3649_IsActivatedByDefault=True
S3649_Remediation=Constant/Issue
S3649_RemediationCost=20min
S3649_Severity=Blocker
S3649_Tags=cwe,owasp-a1,sans-top25-insecure,cert,sql
S3649_Title=User-provided values should be sanitized before use in SQL statements
S3649_Type=VULNERABILITY
S3655_Category=Sonar Bug
S3655_Description=Nullable value types can hold either a value or null. The value held in the nullable type can be accessed with the Value property, but .Value throws an InvalidOperationException when the value is null. To avoid the exception, a nullable type should always be tested before .Value is accessed.
S3655_IsActivatedByDefault=True
S3655_Remediation=Constant/Issue
S3655_RemediationCost=10min
S3655_Severity=Major
S3655_Tags=cwe
S3655_Title=Empty nullable value should not be accessed
S3655_Type=BUG
S3693_Category=Sonar Bug
S3693_Description=It may be a good idea to raise an exception in a constructor if you're unable to fully flesh the object in question, but not in an exception constructor. If you do, you'll interfere with the exception that was originally being thrown. Further, it is highly unlikely that an exception raised in the creation of an exception will be properly handled in the calling code, and the unexpected, unhandled exception will lead to program termination.
S3693_IsActivatedByDefault=True
S3693_Remediation=Constant/Issue
S3693_RemediationCost=15min
S3693_Severity=Blocker
S3693_Tags=
S3693_Title=Exception constructors should not throw exceptions
S3693_Type=BUG
S3717_Category=Sonar Code Smell
S3717_Description=NotImplementedException is often used to mark methods which must be implemented for the overall functionality to be complete, but which the developer wants to implement later. That's as opposed to the NotSupportedException which is thrown by methods which are required by base classes or interfaces, but which are not appropriate to the current class.
S3717_IsActivatedByDefault=False
S3717_Severity=Minor
S3717_Tags=
S3717_Title=Track use of "NotImplementedException"
S3717_Type=CODE_SMELL
S3776_Category=Sonar Code Smell
S3776_Description=Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain.
S3776_IsActivatedByDefault=True
S3776_Remediation=
S3776_RemediationCost=
S3776_Severity=Critical
S3776_Tags=brain-overload
S3776_Title=Cognitive Complexity of methods should not be too high
S3776_Type=CODE_SMELL
S3869_Category=Sonar Bug
S3869_Description=Not surprisingly, the SafeHandle.DangerousGetHandle method is dangerous. That's because it may not return a valid handle. Using it can lead to leaks and vulnerabilities. While it is possible to use the method successfully, it's extremely difficult to do correctly, so the method should simply be avoided altogether.
S3869_IsActivatedByDefault=True
S3869_Remediation=Constant/Issue
S3869_RemediationCost=20min
S3869_Severity=Blocker
S3869_Tags=leak,unpredictable
S3869_Title="SafeHandle.DangerousGetHandle" should not be called
S3869_Type=BUG
S3871_Category=Sonar Code Smell
S3871_Description=The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be public for that to work. 
S3871_IsActivatedByDefault=True
S3871_Remediation=Constant/Issue
S3871_RemediationCost=5min
S3871_Severity=Critical
S3871_Tags=error-handling,api-design
S3871_Title=Exception types should be "public"
S3871_Type=CODE_SMELL
S3872_Category=Sonar Code Smell
S3872_Description=The name of a method should communicate what it does, and the names of its parameters should indicate how they're used. If a method and its parameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language that's not the case, it is still likely to confuse callers and maintainers.
S3872_IsActivatedByDefault=False
S3872_Remediation=Constant/Issue
S3872_RemediationCost=5min
S3872_Severity=Minor
S3872_Tags=convention,confusing
S3872_Title=Parameter names should not duplicate the names of their methods
S3872_Type=CODE_SMELL
S3874_Category=Sonar Code Smell
S3874_Description=Passing a parameter by reference, which is what happens when you use the out or ref parameter modifiers, means that the method will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change the argument's values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when it is what was intended, this is the sort of thing that's difficult to get right, and should be used with caution.
S3874_IsActivatedByDefault=False
S3874_Remediation=Constant/Issue
S3874_RemediationCost=20min
S3874_Severity=Critical
S3874_Tags=suspicious
S3874_Title="out" and "ref" parameters should not be used
S3874_Type=CODE_SMELL
S3875_Category=Sonar Code Smell
S3875_Description=The use of == to compare to objects is expected to do a reference comparison. That is, it is expected to return true if and only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by callers. On the other hand, overloading it to do exactly that is pointless; that's what == does by default.
S3875_IsActivatedByDefault=True
S3875_Remediation=Constant/Issue
S3875_RemediationCost=15min
S3875_Severity=Blocker
S3875_Tags=pitfall
S3875_Title="operator==" should not be overloaded on reference types
S3875_Type=CODE_SMELL
S3876_Category=Sonar Code Smell
S3876_Description=Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and potentially a situation where a method should be used instead.
S3876_IsActivatedByDefault=False
S3876_Remediation=Constant/Issue
S3876_RemediationCost=20min
S3876_Severity=Minor
S3876_Tags=design
S3876_Title=Strings or integral types should be used for indexers
S3876_Type=CODE_SMELL
S3877_Category=Sonar Code Smell
S3877_Description=It is expected that some methods should be called with caution, but others, such as ToString, are expected to "just work". Throwing an exception from such a method is likely to break callers' code unexpectedly.
S3877_IsActivatedByDefault=True
S3877_Remediation=Constant/Issue
S3877_RemediationCost=20min
S3877_Severity=Blocker
S3877_Tags=pitfall
S3877_Title=Exceptions should not be thrown from unexpected methods
S3877_Type=CODE_SMELL
S3880_Category=Sonar Code Smell
S3880_Description=Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no benefit or justification.
S3880_IsActivatedByDefault=False
S3880_Remediation=Constant/Issue
S3880_RemediationCost=2min
S3880_Severity=Major
S3880_Tags=performance
S3880_Title=Finalizers should not be empty
S3880_Type=CODE_SMELL
S3881_Category=Sonar Code Smell
S3881_Description=The IDisposable interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource leaks or more severe bugs.
S3881_IsActivatedByDefault=True
S3881_Remediation=Constant/Issue
S3881_RemediationCost=10min
S3881_Severity=Major
S3881_Tags=pitfall
S3881_Title="IDisposable" should be implemented correctly
S3881_Type=CODE_SMELL
S3884_Category=Sonar Vulnerability
S3884_Description=CoSetProxyBlanket and CoInitializeSecurity both work to set the permissions context in which the process invoked immediately after is executed. Calling them from within that process is useless because it's to late at that point; the permissions context has already been set.
S3884_IsActivatedByDefault=True
S3884_Remediation=Constant/Issue
S3884_RemediationCost=20min
S3884_Severity=Blocker
S3884_Tags=
S3884_Title="CoSetProxyBlanket" and "CoInitializeSecurity" should not be used
S3884_Type=VULNERABILITY
S3885_Category=Sonar Code Smell
S3885_Description=The parameter to Assembly.Load includes the full specification of the dll to be loaded. Use another method, and you might end up with a dll other than the one you expected. 
S3885_IsActivatedByDefault=True
S3885_Remediation=Constant/Issue
S3885_RemediationCost=5min
S3885_Severity=Major
S3885_Tags=unpredictable
S3885_Title="Assembly.Load" should be used
S3885_Type=CODE_SMELL
S3887_Category=Sonar Bug
S3887_Description=Using the readonly keyword on a field means that it can't be changed after initialization. However, when applied to collections or arrays, that's only partly true. readonly enforces that another instance can't be assigned to the field, but it cannot keep the contents from being updated. That means that in practice, the field value really can be changed, and the use of readonly on such a field is misleading, and you're likely to not be getting the behavior you expect.
S3887_IsActivatedByDefault=True
S3887_Remediation=Constant/Issue
S3887_RemediationCost=15min
S3887_Severity=Minor
S3887_Tags=
S3887_Title=Mutable, non-private fields should not be "readonly"
S3887_Type=BUG
S3889_Category=Sonar Bug
S3889_Description=Thread.Suspend and Thread.Resume can give unpredictable results, and both methods have been deprecated. Indeed, if Thread.Suspend is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer synchronization mechanisms should be used, such as Monitor, Mutex, and Semaphore.
S3889_IsActivatedByDefault=True
S3889_Remediation=Constant/Issue
S3889_RemediationCost=20min
S3889_Severity=Blocker
S3889_Tags=multi-threading,unpredictable
S3889_Title=Neither "Thread.Resume" nor "Thread.Suspend" should be used
S3889_Type=BUG
S3897_Category=Sonar Code Smell
S3897_Description=The IEquatable<T> interface has only one method in it: Equals(<T>). If you've already written Equals(T), there's no reason not to explicitly implement IEquatable<T>. Doing so expands the utility of your class by allowing it to be used where an IEquatable is called for.
S3897_IsActivatedByDefault=True
S3897_Remediation=Constant/Issue
S3897_RemediationCost=2min
S3897_Severity=Minor
S3897_Tags=api-design
S3897_Title=Classes that provide "Equals(<T>)" should implement "IEquatable<T>"
S3897_Type=CODE_SMELL
S3898_Category=Sonar Code Smell
S3898_Description=If you're using a struct, it is likely because you're interested in performance. But by failing to implement IEquatable<T> you're loosing performance when comparisons are made because without IEquatable<T>, boxing and reflection are used to make comparisons. 
S3898_IsActivatedByDefault=False
S3898_Remediation=Constant/Issue
S3898_RemediationCost=20min
S3898_Severity=Major
S3898_Tags=performance
S3898_Title=Value types should implement "IEquatable<T>"
S3898_Type=CODE_SMELL
S3900_Category=Sonar Code Smell
S3900_Description=A public method can be called from anywhere, which means you should validate parameters to be within the expected constraints. In general, checking against null is recommended defensive programming.
S3900_IsActivatedByDefault=False
S3900_Remediation=Constant/Issue
S3900_RemediationCost=5min
S3900_Severity=Major
S3900_Tags=convention
S3900_Title=Arguments of public methods should be validated against null
S3900_Type=CODE_SMELL
S3902_Category=Sonar Code Smell
S3902_Description=Using Type.Assembly to get the current assembly is nearly free in terms of performance; it's a simple property access. On the other hand, Assembly.GetExecutingAssembly() can take up to 30 times as long because it walks up the call stack to find the assembly.
S3902_IsActivatedByDefault=False
S3902_Remediation=Constant/Issue
S3902_RemediationCost=5min
S3902_Severity=Major
S3902_Tags=performance
S3902_Title="Assembly.GetExecutingAssembly" should not be called
S3902_Type=CODE_SMELL
S3903_Category=Sonar Bug
S3903_Description=Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are defined outside any named namespace are in a global namespace that cannot be referenced in code.
S3903_IsActivatedByDefault=True
S3903_Remediation=Constant/Issue
S3903_RemediationCost=5min
S3903_Severity=Major
S3903_Tags=
S3903_Title=Types should be defined in named namespaces
S3903_Type=BUG
S3904_Category=Sonar Code Smell
S3904_Description=If no AssemblyVersionAttribute is provided, the same default version will be used for every build. Since the version number is used by The .NET Framework to uniquely identify an assembly this can lead to broken dependencies.
S3904_IsActivatedByDefault=True
S3904_Remediation=Constant/Issue
S3904_RemediationCost=2min
S3904_Severity=Critical
S3904_Tags=pitfall
S3904_Title=Assemblies should have version information
S3904_Type=CODE_SMELL
S3906_Category=Sonar Code Smell
S3906_Description=Delegate event handlers (i.e. delegates used as type of an event) should have a very specific signature:
S3906_IsActivatedByDefault=False
S3906_Remediation=Constant/Issue
S3906_RemediationCost=5min
S3906_Severity=Major
S3906_Tags=convention
S3906_Title=Event Handlers should have the correct signature
S3906_Type=CODE_SMELL
S3908_Category=Sonar Code Smell
S3908_Description=Since .Net Framework version 2.0 it is not necessary to declare a delegate that specifies a class derived from System.EventArgs. The System.EventHandler<TEventArgs> delegate mechanism should be used instead as it allows any class derived from EventArgs to be used with that handler.
S3908_IsActivatedByDefault=False
S3908_Remediation=Constant/Issue
S3908_RemediationCost=15min
S3908_Severity=Major
S3908_Tags=
S3908_Title=Generic event handlers should be used
S3908_Type=CODE_SMELL
S3909_Category=Sonar Code Smell
S3909_Description=The NET Framework 2.0 introduced the generic interface System.Collections.Generic.IEnumerable<T> and it should be preferred over the older, non generic, interfaces.
S3909_IsActivatedByDefault=False
S3909_Remediation=Constant/Issue
S3909_RemediationCost=15min
S3909_Severity=Major
S3909_Tags=
S3909_Title=Collections should implement the generic interface
S3909_Type=CODE_SMELL
S3925_Category=Sonar Code Smell
S3925_Description=The ISerializable interface is the mechanism to control the type serialization process. If not implemented correctly this could result in an invalid serialization and hard to detect bugs.
S3925_IsActivatedByDefault=True
S3925_Remediation=Constant/Issue
S3925_RemediationCost=20min
S3925_Severity=Major
S3925_Tags=pitfall
S3925_Title="ISerializable" should be implemented correctly
S3925_Type=CODE_SMELL
S3926_Category=Sonar Bug
S3926_Description=Fields marked with System.Runtime.Serialization.OptionalFieldAttribute are serialized just like any other field. But such fields are ignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to set such fields during the deserialization process.
S3926_IsActivatedByDefault=True
S3926_Remediation=Constant/Issue
S3926_RemediationCost=10min
S3926_Severity=Major
S3926_Tags=serialization
S3926_Title=Deserialization methods should be provided for "OptionalField" members
S3926_Type=BUG
S3927_Category=Sonar Bug
S3927_Description=Serialization event handlers that don't have the correct signature will simply not be called, thus bypassing any attempts to augment the automated de/serialization.
S3927_IsActivatedByDefault=True
S3927_Remediation=Constant/Issue
S3927_RemediationCost=15min
S3927_Severity=Major
S3927_Tags=
S3927_Title=Serialization event handlers should be implemented correctly
S3927_Type=BUG
S3928_Category=Sonar Code Smell
S3928_Description=Some constructors of the ArgumentException, ArgumentNullException, ArgumentOutOfRangeException and DuplicateWaitObjectException classes must be fed with a valid parameter name. This rule raises an issue in two cases:
S3928_IsActivatedByDefault=True
S3928_Remediation=Constant/Issue
S3928_RemediationCost=2min
S3928_Severity=Major
S3928_Tags=
S3928_Title=Parameter names used into ArgumentException constructors should match an existing one 
S3928_Type=CODE_SMELL
S3956_Category=Sonar Code Smell
S3956_Description=System.Collections.Generic.List<T> is a generic collection that is designed for performance and not inheritance. For example, it does not contain virtual members that make it easier to change the behavior of an inherited class. That means that future attempts to expand the behavior will be spoiled because the extension points simply aren't there. Instead, one of the following generic collections should be used:
S3956_IsActivatedByDefault=False
S3956_Remediation=Constant/Issue
S3956_RemediationCost=10min
S3956_Severity=Major
S3956_Tags=api-design
S3956_Title="Generic.List" instances should not be part of public APIs
S3956_Type=CODE_SMELL
S3962_Category=Sonar Code Smell
S3962_Description=The value of a static readonly field is computed at runtime while the value of a const field is calculated at compile time, which improves performance.
S3962_IsActivatedByDefault=False
S3962_Remediation=Constant/Issue
S3962_RemediationCost=2min
S3962_Severity=Minor
S3962_Tags=performance
S3962_Title="static readonly" constants should be "const" instead
S3962_Type=CODE_SMELL
S3963_Category=Sonar Code Smell
S3963_Description=When a static constructor serves no other purpose that initializing static fields, it comes with an unnecessary performance cost because the compiler generates a check before each static method or instance constructor invocation.
S3963_IsActivatedByDefault=False
S3963_Remediation=Constant/Issue
S3963_RemediationCost=5min
S3963_Severity=Minor
S3963_Tags=
S3963_Title="static" fields should be initialized inline
S3963_Type=CODE_SMELL
S3966_Category=Sonar Code Smell
S3966_Description=A proper implementation of IDisposable.Dispose should allow for it to be called multiple times on the same object, however this is not guaranteed and could result in an exception being thrown.
S3966_IsActivatedByDefault=True
S3966_Remediation=Constant/Issue
S3966_RemediationCost=10min
S3966_Severity=Critical
S3966_Tags=pitfall
S3966_Title=Objects should not be disposed more than once
S3966_Type=CODE_SMELL
S3967_Category=Sonar Code Smell
S3967_Description=A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements can be of different sizes, which avoids wasting memory space.
S3967_IsActivatedByDefault=False
S3967_Remediation=
S3967_RemediationCost=
S3967_Severity=Minor
S3967_Tags=design
S3967_Title=Multidimensional arrays should not be used
S3967_Type=CODE_SMELL
S3971_Category=Sonar Code Smell
S3971_Description=GC.SuppressFinalize requests that the system not call the finalizer for the specified object. This should only be done when implementing Dispose as part of the Dispose Pattern.
S3971_IsActivatedByDefault=True
S3971_Remediation=Constant/Issue
S3971_RemediationCost=2min
S3971_Severity=Major
S3971_Tags=
S3971_Title="GC.SuppressFinalize" should not be called
S3971_Type=CODE_SMELL
S3972_Category=Sonar Code Smell
S3972_Description=Code is clearest when each statement has its own line. Nonetheless, it is a common pattern to combine on the same line an if and it's resulting then statement. However, when an if is placed on the same line as the closing } from a preceding else or else if, it is either an error - else is missing - or the invitation to a future error as maintainers fail to understand that the two statements are unconnected.
S3972_IsActivatedByDefault=True
S3972_Remediation=Constant/Issue
S3972_RemediationCost=10min
S3972_Severity=Critical
S3972_Tags=suspicious
S3972_Title=Conditionals should start on new lines
S3972_Type=CODE_SMELL
S3981_Category=Sonar Bug
S3981_Description=The size of a collection and the length of an array are always greater than or equal to zero. So testing that a size or length is greater than or equal to zero doesn't make sense, since the result is always true. Similarly testing that it is less than zero will always return false. Perhaps the intent was to check the non-emptiness of the collection or array instead. 
S3981_IsActivatedByDefault=True
S3981_Remediation=Constant/Issue
S3981_RemediationCost=2min
S3981_Severity=Major
S3981_Tags=
S3981_Title=Collection sizes and array length comparisons should make sense
S3981_Type=BUG
S3984_Category=Sonar Bug
S3984_Description=Creating a new Exception without actually throwing it is useless and is probably due to a mistake.
S3984_IsActivatedByDefault=True
S3984_Remediation=Constant/Issue
S3984_RemediationCost=2min
S3984_Severity=Major
S3984_Tags=
S3984_Title=Exception should not be created without being thrown 
S3984_Type=BUG
S3990_Category=Sonar Code Smell
S3990_Description=Assemblies should conform with the Common Language Specification (CLS) in order to be usable across programming languages. To be compliant an assembly has to indicate it with System.CLSCompliantAttribute.
S3990_IsActivatedByDefault=False
S3990_Remediation=Constant/Issue
S3990_RemediationCost=1min
S3990_Severity=Major
S3990_Tags=api-design
S3990_Title=Assemblies should be marked as CLS compliant
S3990_Type=CODE_SMELL
S3992_Category=Sonar Code Smell
S3992_Description=Assemblies should explicitly indicate whether they are meant to be COM visible or not. If the ComVisibleAttribute is not present, the default is to make the content of the assembly visible to COM clients.
S3992_IsActivatedByDefault=False
S3992_Remediation=Constant/Issue
S3992_RemediationCost=1min
S3992_Severity=Major
S3992_Tags=api-design
S3992_Title=Assemblies should explicitly specify COM visibility
S3992_Type=CODE_SMELL
S3993_Category=Sonar Code Smell
S3993_Description=When defining custom attributes, System.AttributeUsageAttribute must be used to indicate where the attribute can be applied. This will determine its valid locations in the code.
S3993_IsActivatedByDefault=False
S3993_Remediation=Constant/Issue
S3993_RemediationCost=5min
S3993_Severity=Major
S3993_Tags=api-design
S3993_Title=Custom attributes should be marked with "System.AttributeUsageAttribute"
S3993_Type=CODE_SMELL
S3994_Category=Sonar Code Smell
S3994_Description=String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred. At minimum, an overload of the method taking a System.Uri as a parameter should be provided in each class that contains a method with an apparent Uri passed as a string.
S3994_IsActivatedByDefault=False
S3994_Remediation=Constant/Issue
S3994_RemediationCost=10min
S3994_Severity=Major
S3994_Tags=
S3994_Title=URI Parameters should not be strings
S3994_Type=CODE_SMELL
S3995_Category=Sonar Code Smell
S3995_Description=String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
S3995_IsActivatedByDefault=False
S3995_Remediation=Constant/Issue
S3995_RemediationCost=10min
S3995_Severity=Major
S3995_Tags=
S3995_Title=URI return values should not be strings
S3995_Type=CODE_SMELL
S3996_Category=Sonar Code Smell
S3996_Description=String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
S3996_IsActivatedByDefault=False
S3996_Remediation=Constant/Issue
S3996_RemediationCost=10min
S3996_Severity=Major
S3996_Tags=
S3996_Title=URI properties should not be strings
S3996_Type=CODE_SMELL
S3997_Category=Sonar Code Smell
S3997_Description=String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
S3997_IsActivatedByDefault=False
S3997_Remediation=Constant/Issue
S3997_RemediationCost=5min
S3997_Severity=Major
S3997_Tags=
S3997_Title=String URI overloads should call "System.Uri" overloads
S3997_Type=CODE_SMELL
S3998_Category=Sonar Code Smell
S3998_Description=A thread acquiring a lock on an object that can be accessed across application domain boundaries runs the risk of being blocked by another thread in a different application domain. Objects that can be accessed across application domain boundaries are said to have weak identity. Types with weak identity are:
S3998_IsActivatedByDefault=True
S3998_Remediation=Constant/Issue
S3998_RemediationCost=10min
S3998_Severity=Critical
S3998_Tags=multi-threading,pitfall
S3998_Title=Threads should not lock on objects with weak identity
S3998_Type=CODE_SMELL
S4000_Category=Sonar Code Smell
S4000_Description=The IntPtr and UIntPtr types are used to access unmanaged memory, usually in order to use C or C++ libraries. If such a pointer is not secured by making it private, internal or readonly, it can lead to a vulnerability allowing access to arbitrary locations.
S4000_IsActivatedByDefault=False
S4000_Remediation=Constant/Issue
S4000_RemediationCost=5min
S4000_Severity=Critical
S4000_Tags=
S4000_Title=Pointers to unmanaged memory should not be visible
S4000_Type=CODE_SMELL
S4002_Category=Sonar Code Smell
S4002_Description=This rule raises an issue when a disposable type contains fields of the following types and does not implement a finalizer:
S4002_IsActivatedByDefault=False
S4002_Severity=Major
S4002_Tags=
S4002_Title=Disposable types should declare finalizers
S4002_Type=CODE_SMELL
S4004_Category=Sonar Code Smell
S4004_Description=A writable collection property can be replaced by a completely different collection. Making it readonly prevents that while still allowing individual members to be set. If you want to allow the replacement of the whole collection the recommended pattern is to implement a method to remove all the elements (e.g. System.Collections.List<T>.Clear) and a method to populate the collection (e.g. System.Collections.List<T>.AddRange).
S4004_IsActivatedByDefault=False
S4004_Remediation=Constant/Issue
S4004_RemediationCost=5min
S4004_Severity=Major
S4004_Tags=
S4004_Title=Collection properties should be readonly
S4004_Type=CODE_SMELL
S4005_Category=Sonar Code Smell
S4005_Description=String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
S4005_IsActivatedByDefault=False
S4005_Remediation=Constant/Issue
S4005_RemediationCost=2min
S4005_Severity=Major
S4005_Tags=
S4005_Title="System.Uri" arguments should be used instead of strings
S4005_Type=CODE_SMELL
S4015_Category=Sonar Code Smell
S4015_Description=Changing an inherited member to private will not prevent access to the base class implementation.
S4015_IsActivatedByDefault=True
S4015_Remediation=Constant/Issue
S4015_RemediationCost=2min
S4015_Severity=Critical
S4015_Tags=pitfall
S4015_Title=Inherited member visibility should not be decreased
S4015_Type=CODE_SMELL
S4016_Category=Sonar Code Smell
S4016_Description=If an enum member's name contains the word "reserved" it implies it is not currently used and will be change in the future. However changing an enum member is a breaking change and can create significant problems. There is no need to reserve an enum member since a new member can be added in the future, and such an addition will usually not be a breaking change.
S4016_IsActivatedByDefault=True
S4016_Remediation=Constant/Issue
S4016_RemediationCost=2min
S4016_Severity=Major
S4016_Tags=
S4016_Title=Enumeration members should not be named "Reserved"
S4016_Type=CODE_SMELL
S4017_Category=Sonar Code Smell
S4017_Description=A nested type is a type argument that is also a generic type. Calling a method with such a nested type argument requires complicated and confusing code. It should be avoided as much as possible.
S4017_IsActivatedByDefault=False
S4017_Remediation=Constant/Issue
S4017_RemediationCost=30min
S4017_Severity=Major
S4017_Tags=confusing
S4017_Title=Method signatures should not contain nested generic types
S4017_Type=CODE_SMELL
S4018_Category=Sonar Code Smell
S4018_Description=The best way to determine the type of a generic method is by inference based on the type of argument that is passed to the method. This is not possible when a parameter type is missing from the argument list.
S4018_IsActivatedByDefault=False
S4018_Remediation=Constant/Issue
S4018_RemediationCost=15min
S4018_Severity=Major
S4018_Tags=
S4018_Title=Generic methods should provide type parameters
S4018_Type=CODE_SMELL
S4019_Category=Sonar Code Smell
S4019_Description=When a method in a derived class has the same name as a method in the base class but with a signature that only differs by types that are weakly derived (e.g. object vs string), the result is that the base method becomes hidden.
S4019_IsActivatedByDefault=True
S4019_Remediation=Constant/Issue
S4019_RemediationCost=5min
S4019_Severity=Critical
S4019_Tags=pitfall
S4019_Title=Base class methods should not be hidden
S4019_Type=CODE_SMELL
S4022_Category=Sonar Code Smell
S4022_Description=By default the storage type of an enum is Int32. In most cases it is not necessary to change this. In particular you will not achieve any performance gain by using a smaller data type (e.g. Byte) and may limit future uses.
S4022_IsActivatedByDefault=False
S4022_Remediation=Constant/Issue
S4022_RemediationCost=2min
S4022_Severity=Minor
S4022_Tags=
S4022_Title=Enumerations should have "Int32" storage
S4022_Type=CODE_SMELL
S4023_Category=Sonar Code Smell
S4023_Description=Empty interfaces are usually used as a marker or a way to identify groups of types. The preferred way to achieve this is to use custom attributes.
S4023_IsActivatedByDefault=False
S4023_Remediation=Constant/Issue
S4023_RemediationCost=2min
S4023_Severity=Minor
S4023_Tags=
S4023_Title=Interfaces should not be empty
S4023_Type=CODE_SMELL
S4025_Category=Sonar Code Smell
S4025_Description=Having a field in a child class with a name that differs from a parent class' field only by capitalization is sure to cause confusion. Such child class fields should be renamed.
S4025_IsActivatedByDefault=False
S4025_Remediation=Constant/Issue
S4025_RemediationCost=5min
S4025_Severity=Critical
S4025_Tags=pitfall
S4025_Title=Child class fields should not differ from parent class fields only be capitalization
S4025_Type=CODE_SMELL
S4026_Category=Sonar Code Smell
S4026_Description=It is important to inform the ResourceManager of the language used to display the resources of the neutral culture for an assembly. This improves lookup performance for the first resource loaded. 
S4026_IsActivatedByDefault=False
S4026_Remediation=Constant/Issue
S4026_RemediationCost=2min
S4026_Severity=Minor
S4026_Tags=performance
S4026_Title=Assemblies should be marked with "NeutralResourcesLanguageAttribute"
S4026_Type=CODE_SMELL
S4027_Category=Sonar Code Smell
S4027_Description=Exceptions types should provide the following constructors:
S4027_IsActivatedByDefault=False
S4027_Remediation=Constant/Issue
S4027_RemediationCost=10min
S4027_Severity=Minor
S4027_Tags=convention
S4027_Title=Exceptions should provide standard constructors
S4027_Type=CODE_SMELL
S4035_Category=Sonar Code Smell
S4035_Description=When a class implements the IEquatable<T> interface, it enters a contract that, in effect, states "I know how to compare two instances of type T or any type derived from T for equality.". However if that class is derived, it is very unlikely that the base class will know how to make a meaningful comparison. Therefore that implicit contract is now broken.
S4035_IsActivatedByDefault=True
S4035_Remediation=Constant/Issue
S4035_RemediationCost=2min
S4035_Severity=Major
S4035_Tags=pitfall
S4035_Title=Classes implementing "IEquatable<T>" should be sealed
S4035_Type=CODE_SMELL
S4039_Category=Sonar Code Smell
S4039_Description=When a base type explicitly implements a public interface method, that method is only accessible in derived types through a reference to the current instance (namely this). If the derived type explicitly overrides that interface method, the base implementation becomes inaccessible.
S4039_IsActivatedByDefault=False
S4039_Remediation=Constant/Issue
S4039_RemediationCost=5min
S4039_Severity=Critical
S4039_Tags=pitfall
S4039_Title=Interface methods should be callable by derived types
S4039_Type=CODE_SMELL
S4040_Category=Sonar Code Smell
S4040_Description=Certain characters, once normalized to lowercase, cannot make a round trip. That is, they can not be converted from one locale to another and then accurately restored to their original characters.
S4040_IsActivatedByDefault=False
S4040_Remediation=Constant/Issue
S4040_RemediationCost=2min
S4040_Severity=Minor
S4040_Tags=pitfall
S4040_Title=Strings should be normalized to uppercase
S4040_Type=CODE_SMELL
S4041_Category=Sonar Code Smell
S4041_Description=When a type name matches the name of a publicly defined namespace, for instance one in the .NET framework class library, it leads to confusion and makes the library that much harder to use.
S4041_IsActivatedByDefault=False
S4041_Remediation=Constant/Issue
S4041_RemediationCost=2min
S4041_Severity=Minor
S4041_Tags=convention
S4041_Title=Type names should not match namespaces
S4041_Type=CODE_SMELL
S4047_Category=Sonar Code Smell
S4047_Description=When a reference parameter (keyword ref) is used, the passed argument type must exactly match the reference parameter type. This means that to be able to pass a derived type, it must be cast and assigned to a variable of the proper type. Use of generic methods eliminates that cumbersome down casting and should therefore be preferred.
S4047_IsActivatedByDefault=False
S4047_Remediation=Constant/Issue
S4047_RemediationCost=10min
S4047_Severity=Minor
S4047_Tags=
S4047_Title=Generics should be used when appropriate
S4047_Type=CODE_SMELL
S4049_Category=Sonar Code Smell
S4049_Description=Properties are accessed like fields which makes them easier to use.
S4049_IsActivatedByDefault=False
S4049_Remediation=Constant/Issue
S4049_RemediationCost=5min
S4049_Severity=Minor
S4049_Tags=convention
S4049_Title=Properties should be preferred
S4049_Type=CODE_SMELL
S4050_Category=Sonar Code Smell
S4050_Description=When implementing operator overloads, it is very important to make sure that all related operators and methods are consistent in their implementation.
S4050_IsActivatedByDefault=False
S4050_Remediation=Constant/Issue
S4050_RemediationCost=10min
S4050_Severity=Major
S4050_Tags=pitfall
S4050_Title=Operators should be overloaded consistently
S4050_Type=CODE_SMELL
S4052_Category=Sonar Code Smell
S4052_Description=With the advent of .NET framework version 2, certain practices have become obsolete.
S4052_IsActivatedByDefault=False
S4052_Remediation=Constant/Issue
S4052_RemediationCost=10min
S4052_Severity=Minor
S4052_Tags=
S4052_Title=Types should not extend outdated base types
S4052_Type=CODE_SMELL
S4055_Category=Sonar Code Smell
S4055_Description=String literals embedded in the source code will not be localized properly.
S4055_IsActivatedByDefault=False
S4055_Remediation=Constant/Issue
S4055_RemediationCost=10min
S4055_Severity=Major
S4055_Tags=localisation,pitfall
S4055_Title=Literals should not be passed as localized parameters
S4055_Type=CODE_SMELL
S4056_Category=Sonar Code Smell
S4056_Description=When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales.
S4056_IsActivatedByDefault=False
S4056_Remediation=Constant/Issue
S4056_RemediationCost=5min
S4056_Severity=Minor
S4056_Tags=localisation,pitfall
S4056_Title=Overloads with a "CultureInfo" or an "IFormatProvider" parameter should be used
S4056_Type=CODE_SMELL
S4057_Category=Sonar Code Smell
S4057_Description=When you create a DataTable or DataSet, you should set the locale explicitly. By default, the locale for these types is the current culture. For data that is stored in a database or file and is shared globally, the locale should ordinarily be set to the invariant culture (CultureInfo.InvariantCulture).
S4057_IsActivatedByDefault=False
S4057_Remediation=Constant/Issue
S4057_RemediationCost=5min
S4057_Severity=Major
S4057_Tags=localisation
S4057_Title=Locales should be set for data types
S4057_Type=CODE_SMELL
S4058_Category=Sonar Code Smell
S4058_Description=Many string operations, the Compare and Equals methods in particular, provide an overload that accepts a StringComparison enumeration value as a parameter. Calling these overloads and explicitly providing this parameter makes your code clearer and easier to maintain.
S4058_IsActivatedByDefault=False
S4058_Remediation=Constant/Issue
S4058_RemediationCost=2min
S4058_Severity=Minor
S4058_Tags=
S4058_Title=Overloads with a "StringComparison" parameter should be used
S4058_Type=CODE_SMELL
S4059_Category=Sonar Code Smell
S4059_Description=Properties and Get method should have names that makes them clearly distinguishable.
S4059_IsActivatedByDefault=False
S4059_Remediation=Constant/Issue
S4059_RemediationCost=2min
S4059_Severity=Major
S4059_Tags=confusing
S4059_Title=Property names should not match get methods
S4059_Type=CODE_SMELL
S4060_Category=Sonar Code Smell
S4060_Description=The .NET framework class library provides methods for retrieving custom attributes. Sealing the attribute eliminates the search through the inheritance hierarchy, and can improve performance.
S4060_IsActivatedByDefault=False
S4060_Remediation=Constant/Issue
S4060_RemediationCost=2min
S4060_Severity=Minor
S4060_Tags=performance
S4060_Title=Non-abstract attributes should be sealed
S4060_Type=CODE_SMELL
S4061_Category=Sonar Code Smell
S4061_Description=A method using the VarArgs calling convention is not Common Language Specification (CLS) compliant and might not be accessible across programming languages, while the params keyword works the same way and is CLS compliant.
S4061_IsActivatedByDefault=False
S4061_Remediation=Constant/Issue
S4061_RemediationCost=5min
S4061_Severity=Minor
S4061_Tags=
S4061_Title="params" should be use instead of "varargs"
S4061_Type=CODE_SMELL
S4069_Category=Sonar Code Smell
S4069_Description=Operator overloading is convenient but unfortunately not portable across languages. To be able to access the same functionality from another language you need to provide an alternate named method following the convention:
S4069_IsActivatedByDefault=False
S4069_Remediation=Constant/Issue
S4069_RemediationCost=5min
S4069_Severity=Minor
S4069_Tags=convention
S4069_Title=Operator overloads should have named alternatives
S4069_Type=CODE_SMELL
S4070_Category=Sonar Code Smell
S4070_Description=This rule raises an issue when an externally visible enumeration is marked with FlagsAttribute and one, or more, of its values is not a power of 2 or a combination of the other defined values.
S4070_IsActivatedByDefault=False
S4070_Remediation=Constant/Issue
S4070_RemediationCost=2min
S4070_Severity=Major
S4070_Tags=
S4070_Title=Non-flags enums should not be marked with "FlagsAttribute"
S4070_Type=CODE_SMELL
S818_Category=Sonar Code Smell
S818_Description=Using upper case literal suffixes removes the potential ambiguity between "1" (digit 1) and "l" (letter el) for declaring literals.
S818_IsActivatedByDefault=True
S818_Remediation=Constant/Issue
S818_RemediationCost=2min
S818_Severity=Minor
S818_Tags=convention,misra,cert,pitfall
S818_Title=Literal suffixes should be upper case
S818_Type=CODE_SMELL
S907_Category=Sonar Code Smell
S907_Description=goto is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such as if, for, while, continue or break should be used instead.
S907_IsActivatedByDefault=True
S907_Remediation=Constant/Issue
S907_RemediationCost=10min
S907_Severity=Major
S907_Tags=brain-overload,misra
S907_Title="goto" statement should not be used
S907_Type=CODE_SMELL
S927_Category=Sonar Code Smell
S927_Description=The name of a parameter in an externally visible method override does not match the name of the parameter in the base declaration of the method, or the name of the parameter in the interface declaration of the method or the name of any other partial definition.
S927_IsActivatedByDefault=True
S927_Remediation=Constant/Issue
S927_RemediationCost=10min
S927_Severity=Critical
S927_Tags=misra,cert,suspicious
S927_Title=parameter names should match base declaration and other partial definitions
S927_Type=CODE_SMELL
