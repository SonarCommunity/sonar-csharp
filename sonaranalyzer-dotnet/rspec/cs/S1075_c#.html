<p>Hard coding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may
not exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems
usually differ from the development environment, ...etc. For all those reasons, a URI should never be hard coded. Instead, it should be replaced by
customizable parameter.</p>
<p>Further even if the elements of a URI are obtained dynamically, portability can still be limited if the path-delimiters are hard-coded.</p>
<p>This rule raises an issue when URI's or path delimiters are hard coded.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using System;

namespace GlobalizationLibrary
{
   class WriteSpecialFolders
   {
      static void Main()
      {
         string string0 = "C:";

         // Each of the following three strings violates the rule.
         string string1 = @"\Documents and Settings";
         string string2 = @"\All Users";
         string string3 = @"\Application Data";
         Console.WriteLine(string0 + string1 + string2 + string3);
      }
   }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using System;

namespace GlobalizationLibrary
{
   class WriteSpecialFolders
   {
      static void Main()
      {
         // The following statement satisfies the rule.
         Console.WriteLine(Environment.GetFolderPath(
            Environment.SpecialFolder.CommonApplicationData));
      }
   }
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/qQCHAQ">CERT, MSC03-J.</a> - Never hard code sensitive information </li>
</ul>

